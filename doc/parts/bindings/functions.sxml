<section id="bindings/functions">
<title>Functions</title>
<top>
<p>These are the functions!</p>

<p>After all, <str-Shapes /> is a special-purpose language aimed at the production of graphics.  Hence, functions for path drawing, creation of affine transforms, and path computations are a very important part of the language.</p>

<p>Remember <binding name="immerse" /> and <binding name="facing" />, and in particular the <arg name="scale" /> and <arg name="distort" /> options to <binding name="facing" />.  The following is quite nice:
</p>
<pre>
facing: [../facing scale:true distort:true ...]
</pre>
</top>

<system-binding identifier="affinetransform">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg>
					<type><named-type name="FloatPair" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatPair" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform from multiplier for x and y coordinates, followed by a shift.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="affinetransform3D">
	<function>
		<case constructor-of="Transform3D">
			<arguments>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform from multiplier for x, y, and z coordinates, followed by a shift.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="shift">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg>
					<type><named-type name="Coords" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform.</description>
		</case>
		<case constructor-of="Transform3D">
			<arguments>
				<arg>
					<type><named-type name="Coords3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="rotate">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg identifier="angle">
					<type><named-type name="Float" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="rotate3D">
	<function>
		<case constructor-of="Transform3D">
			<arguments>
				<arg identifier="dir">
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg identifier="angle">
					<type><named-type name="Float" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct rotation transform about given direction.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="scale">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg identifier="r">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="x">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="y">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform that scales x by <arg name="r" /><char-cdot /><arg name="x" />, and y by <arg name="r" /><char-cdot /><arg name="y" />.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="scale3D">
	<function>
		<case constructor-of="Transform3D">
			<arguments>
				<arg identifier="r">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="x">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="y">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="z">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform that scales x by <arg name="r" /><char-cdot /><arg name="x" />, and similarly with y and z.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="inverse">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg>
					<type><named-type name="Transform" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Constructs the inverse of a transform.  This is only possible if the linear part of the transform is non-singular.</description>
		</case>
		<case constructor-of="Transform3D">
			<arguments>
				<arg>
					<type><named-type name="Transform3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Constructs the inverse of a transform.  This is only possible if the linear part of the transform is non-singular.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="stroke">
	<function>
		<case constructor-of="Drawable">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
				<arg identifier="head">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead" /></type>
				</arg>
				<arg identifier="tail">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="width" /> <dynvar name="stroking" /> <dynvar name="dash" /> <dynvar name="cap" /> <dynvar name="join" /> <dynvar name="miterlimit" /></dynamic-references>
			<description>
				<p>Paints the <arg name="path" /> argument by stroking it.  Properties such as color (<dynvar name="stroking" />), width, <abbr-etc /> are taken from the dynamic environment.</p>
				<p>The arguments <arg name="head" /> and <arg name="tail" /> define arrowheads at the corresponding ends of the stroke.  An arrowhead is defined by a function that takes the path as argument, and returns a tuple with fields <field name="picture" /> and <field name="cut" />.  Here, <field name="picture" /> shall be the grahpics that is the actual arrowhead, while <field name="cut" /> tells how much the stroke shall be shortened to not interfere with the arrowhead.  Note that the arrowhead and the stroke usually overlap, but that it is not desirable that the stroke goes all the way to the point of the arrowhead.</p>
			</description>
		</case>
		<case constructor-of="Drawable3D">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg identifier="head">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead3D" /></type>
				</arg>
				<arg identifier="tail">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead3D" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="width" /> <dynvar name="stroking" /> <dynvar name="dash" /> <dynvar name="cap" /> <dynvar name="join" /> <dynvar name="miterlimit" /></dynamic-references>
			<description>
				<p>Compare with the <str-2D /> case.</p>
				<p>Note that defining arrow heads is much more intricate in <str-3D /> than in <str-2D />, and generally requires knowledge of from what angle the arrowhead will later be viewed.  If one is really eager to work around this “problem”, then what one is typically looking for is a way to delay the definition of the arrowhead until the viewing angle is known.  The key to the solution is <binding name="facing" />.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="fill">
	<function>
		<case constructor-of="Drawable">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="nonstroking" /></dynamic-references>
			<description>
				<p>Paints the <arg name="path" /> (that shall be closed) argument by filling it.  The fill color is taken from <dynvar>nonstroking</dynvar>.</p>
			</description>
		</case>
		<case constructor-of="Drawable3D">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg identifier="tiebreaker">
					<default>0</default>
					<type><named-type name="Length" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="nonstroking" /></dynamic-references>
			<description>
				<p>Paints the <arg name="path" /> (that shall be closed) argument by filling it.  The fill color is taken from <dynvar>nonstroking</dynvar>.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="facing">
	<function>
		<case constructor-of="Drawable3D">
			<arguments>
				<arg identifier="obj">
					<type><named-type name="Drawable" /></type>
				</arg>
				<arg identifier="scale">
					<type><named-type name="Boolean" /></type>
					<default>false</default>
				</arg>
				<arg identifier="distort">
					<type><named-type name="Boolean" /></type>
					<default>false</default>
				</arg>
			</arguments>
			<description>
				<p>Creates an object in <str-3D /> which is always facing the viewer.  It is useful for labels and other <str-2D /> annotations that need to be positioned in terms of objects in a <str-3D /> world.  The <arg name="scale" /> and <arg name="distort" /> arguments control how to interpret the <str-3D /> transform when the object is being viewed.</p>
			</description>
		</case>
		<case constructor-of="Drawable3D">
			<arguments>
				<arg identifier="obj">
					<type>
						<function-type>
							<arguments>
								<arg><named-type name="Transform3D" /></arg>
							</arguments>
							<result><named-type name="Drawable" /></result>
						</function-type>
					</type>
				</arg>
			</arguments>
			<dynamic-references><dynstate name="all" /></dynamic-references>
			<description>
				<p>Gives the user full control of how to display the object when being viewed through a <str-3D /> transform.  The dynamic state is captured, and will be in scope later when the embedded function is invoked.</p>

				<note>
					<p>The evaluation order is quite non-standard for the objects created here.  Viewing an object is generally an atomic operation from a continuation passing point of view.  Hence, when the function is applied to the transform to obtain the <str-2D /> result, this will take place in an evaluation loop of its own.  This is very likely to render generated error messages rather useless when it comes to localizing the problem.</p>
					<p>Since the object created here only has a meaning when being viewed, it cannot be searched (see <binding name="tag" /> and <binding name="find" />) for tags as long as it remains in <str-3D />.</p>
				</note>

				<p>If you ever considered solving the intricate problem of generating nice arrowheads for paths in <str-3D /> by simply treating the path as if it was in <str-2D />, think again, as the example below shows!</p>

				<example-with-output title="Example" internal-id="example/facing-function">
					<image pdf="facefun_3.pdf" jpg="facefun_y_big.jpg" />
<source file=<!--#expand-next-string-->"$(EXAMPLES)/features/facefun.shape">
<![CDATA[<!--#include virtual="$(EXAMPLES)/features/facefun.shape" -->]]>
</source>
				</example-with-output>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="range">
	<function>
		<case constructor-of="SingleList">
			<arguments>
				<arg identifier="begin">
					<type><named-type name="Integer" /></type>
				</arg>
				<arg identifier="end">
					<type><named-type name="Integer" /></type>
				</arg>
				<arg identifier="step">
					<type><named-type name="Integer" /></type>
				</arg>
				<arg identifier="count">
					<type><named-type name="Integer" /></type>
				</arg>
			</arguments>
			<description>
				<p>Constructs a range of integers.  One of the arguments must be omitted, and it is forbidden to provide <arg name="begin" />, <arg name="end" />, and <arg name="count" /> at the same time.  It is allowed to omit both <arg name="step" /> and <arg name="count" />, in which case <arg name="step" /> defaults to (a positive) 1.</p>
				<p>See the float case for the semantics of the various argument combinations.</p>
			</description>
		</case>
		<case constructor-of="SingleList">
			<arguments>
				<arg identifier="begin">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="end">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="step">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="count">
					<type><named-type name="Integer" /></type>
				</arg>
			</arguments>
			<description>
				<p>Constructs a range of real numbers.  One of the arguments must be omitted.  It is allowed to omit both <arg name="step" /> and <arg name="count" />, in which case <arg name="step" /> defaults to (a positive) 1.</p>
				<p>If <arg name="step" /> is provided, it determines the step length.  If <arg name="count" /> is provided, it must be at least 2, and determines the number of elements in the constructed range, which will begin at <arg name="begin" /> if <arg name="begin" /> is provided, and end at <arg name="end" /> if <arg name="end" /> is provided (note that achieving this using <arg name="step" /> may be inconvenient or even difficult due to problems with numeric precision).  If neither <arg name="step" /> nor <arg name="count" /> is provided, <arg name="step" /> defaults to 1.</p>
			</description>
		</case>
		<case constructor-of="SingleList">
			<arguments>
				<arg identifier="begin">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="end">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="step">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="count">
					<type><named-type name="Integer" /></type>
				</arg>
			</arguments>
			<description>
				<p>Constructs a range of integers.  One of the arguments must be omitted, and it is forbidden to omit both <arg name="step" /> and <arg name="count" />.</p>
				<p>See the float case for the semantics of the various argument combinations.</p>
			</description>
		</case>
		<body>
			<example-with-output title="Range construction" internal-id="example/ranges">
<source file=<!--#expand-next-string-->"$(EXAMPLES)/features/ranges.shape">
<![CDATA[<!--#include virtual="$(EXAMPLES)/features/ranges.shape" -->]]>
</source>
<stdout>
<![CDATA[<!--#include virtual="$(EXAMPLES_OUTPUT)/ranges.stdout" -->]]>
</stdout>
			</example-with-output>
		</body>
	</function>
</system-binding>

<system-binding identifier="reverse">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Construct path where the order of pathpoints in the representation is reversed.  The constructed path looks identical to the original.</p>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="meetpaths">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Merge the two paths by merging the <field name="end" /> point of the first path with the <field name="begin" /> point of the second path.  It is not required for the two paths to intersect;  the merge operation is defined anyway by replacing the two merged points with one at the mean, taking one interpolation point form each path.  Use this to avoid vanishing spline segments when joining two consecutive paths.</p>
				<p>Hopefully, the example below expresses the idea more clearly.</p>
				<example-with-output title="Merging paths" internal-id="example/meetpaths">
					<image pdf="mergepaths_3.pdf" jpg="mergepaths_y_big.jpg" />
<source file=<!--#expand-next-string-->"$(EXAMPLES)/showcase/mergepaths.shape">
<![CDATA[<!--#include virtual="$(EXAMPLES)/showcase/mergepaths.shape" -->]]>
</source>
<caption>
	<p>Application of <binding name="meetpaths" />.  Note that the interesting stuff is found in <a extension="linkpaths" />.</p>
</caption>
				</example-with-output>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_balance">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Divide each spline segment in two such that the velocity is continuous at the new path point.  This will make the distance to the two interpolation points at the new path point equal, hence the name.  It turns out that this happens at spline time 0.5, so the implementation is very cheap.</p>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_inflections">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Add samples at inflection points.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_bends">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg identifier="angle">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Add samples at inflection points, and so that each segment bends at most <arg name="angle" />.  Segments that need upsampling (after inflections have been removed) are sampled evenly with respect to direction.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_every">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg identifier="period">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Add sample points such that each segment is at most <arg name="period" /> long.  Segments that need upsampling are sampled evenly with respect to arc length.</p>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg identifier="period">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="path">
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>


</section>
