|** This example is included to compare Drool with Sketch.
|** Kjell Magne Fauske draw a nice robot arm using Sketch, and I want to see
|** what the corresponding Drool source could look like (if possible to reproduce at all).
|** Many thanks to Kjell Magne for letting me use his example.


#unit u = 1cm


cylinderWall: \ radius height sides .>
{
  deltaAngle: 360° / sides
  r: radius * ( 2 / ( 1 + [cos deltaAngle / 2] ) )
  oneSide: [facet (r,0u,0u)--(r*[cos deltaAngle],r*[sin deltaAngle],0u)--(r*[cos deltaAngle],r*[sin deltaAngle],height)--(r,0u,height)--cycle
                 [facetnormal (r,0u,0u) (1,0,0)] [facetnormal (r*[cos deltaAngle],r*[sin deltaAngle],0u) ([cos deltaAngle],[sin deltaAngle],0)] ]

  res: Hot3D <<

  ![[range '0 sides-'1].foldl
   \ p e .>
    !{
      res << [rotate3D (0,0,1) e*deltaAngle] [] oneSide
      p
    }
   VOID]

  res;
  res
}

polyDisc: \ radius sides .>
{
  deltaAngle: 360° / sides
  r: radius * ( 2 / ( 1 + [cos deltaAngle / 2] ) )
  [[range '0 sides-'1].foldl
   \ pile e .>  pile--( r * [dir deltaAngle * e] )
   EMPTYPATH2D]--cycle
}

cylinderLid: \ radius height sides smallRadius .>
{
  [shift (0cm,0cm,height)] [] ( Hot3D << [facet [immerse [polyDisc radius sides]]]
                                      << @nonstroking:[gray 0.3] | [facet [immerse [polyDisc smallRadius sides]] tiebreaker:1bp]
                                )
}

|** First object to be defined is a joint.

jointRadius: 1u
jointThickness: 0.5u  |** Take this times two to obtain the total height.
jointSurface:
    @nonstroking:[gray 0.8]
  & @reflections:0.3*[phong 25] + 0.7*[phong 0.5]
  & @facetresolution:0.5u


zbuf: HotZSorter <<

jointSides: '15

joint: [rotate3D (1,0,0) ~90°] []
         ( jointSurface | ( Hot3D << [cylinderWall jointRadius 2*jointThickness jointSides]
                                  << [cylinderLid jointRadius 0bp jointSides 0.3*jointRadius]
                                  << [cylinderLid jointRadius 2*jointThickness jointSides 0.3*jointRadius]
		     	          << @stroking:RGB_RED | [stroke (0cm,0cm,~2.5*jointThickness)--(0cm,0cm,4.5*jointThickness)]
                            ) )

armTwist: 45°
armPath: \ tfStart tfEnd .>
{
  pStart: tfStart [] (0u,jointThickness,0u)
  pEnd: tfEnd [] (0u,jointThickness,0u)
  hr: 0.4 * [abs pEnd - pStart]

  pStart > (tfStart [] ([rotate3D (0,1,0) ~armTwist] [] (hr,jointThickness,0u)))
  --
  (tfEnd [] ([rotate3D (0,1,0) armTwist] [] (~hr,jointThickness,0u))) < pEnd
}

edgyCylinder: \ pth0 pth1 .>
{
  res: Hot3D <<

  ![if [duration pth0] <> [duration pth1]
       [error `edgyCylinder: Paths don't have the same duration.´]]

  ![[range '0 [duration pth0]-'1].foldl
   \ p e .>
    !{
      res << [facet [pth0 e*1].p--[pth0 (e+'1)*1].p--[pth1 (e+'1)*1].p--cycle]
      res << [facet [pth0 e*1].p--[pth1 (e+'1)*1].p--[pth1 e*1].p--cycle]
      p
    }
   VOID]

  res;
  res
}

paintArm: \ pth width height steps .>
{
  lStep: [abs pth] / steps

  res: Hot3D <<

  ![[range '0 steps-'1].foldl
   \ p e .>
    !{
      pth0:
      {
        sl: [pth e*lStep]
	dx: sl.N * 0.5 * width
	dy: sl.B * 0.5 * height
	[shift sl.p] [] ( (~dx+~dy)--(~dx+dy)--(dx+dy)--(dx+~dy)--cycle )
      }

      pth1:
      {
        sl: [pth (e+'1)*lStep]
	dx: sl.N * 0.5 * width
	dy: sl.B * 0.5 * height
	[shift sl.p] [] ( (~dx+~dy)--(~dx+dy)--(dx+dy)--(dx+~dy)--cycle )
      }

      res << [edgyCylinder pth0 pth1]

      p
    }
   VOID]

  res;
  res
}

|** Numbers seen in figure:
a0: 5u
alpha0: 15°
a1: 6.5u
theta1: 25°
alpha1: 0°

/** Setup frames according to figure.  The tf_a transforms define the frame after a joint,
 ** and the tf_b transforms define the frame just before the next joint.  The difference between
 ** adjacent tf_b and tf_a is thus a shift in the y-direction and a rotation about the y-axis.
 **/
tf0a: [rotate3D (1,0,0) 15°] * [rotate3D (0,1,0) ~5°]
tf0b: tf0a * [shift (a0,0u,0u)] * [rotate3D (1,0,0) alpha0]
tf1a: tf0b * [shift (0u,2*jointThickness+0.1u,0u)] * [rotate3D (0,1,0) theta1]
tf1b: tf1a * [shift (a1,0u,0u)] * [rotate3D (1,0,0) alpha1]

zbuf << tf0a [] joint
zbuf << tf0b [] joint
zbuf << tf1a [] joint
zbuf << tf1b [] joint

zbuf << jointSurface | [paintArm [armPath tf0a tf0b] 0.5*jointRadius 0.2*jointRadius '10]
|** zbuf << jointSurface | [paintArm [armPath tf1a tf1b] 0.5*jointRadius 0.2*jointRadius '10]

zbuf << [shift (0cm,0cm,10cm)] [] [specular_light [gray 0.9]]
zbuf << [ambient_light [gray 0.3]]
zbuf;

@<< @nonstroking:RGB_GREEN | [fill [rectangle (~3u,~3u) (3u,3u)]]
@<< @eyez:40u|[view zbuf]
