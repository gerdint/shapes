<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<html>
<head>
  <title>The Shapes language documentation</title>
  <link rel="stylesheet" href="../shapes.css">
</head>
<body>

<h1>Language reference</h1>
<p>Without a reference documentation, the lanugage would not be defined.  On the other hand, the structure of a reference documentation may not suit new users of the language, but writing an instructional text will be postponed until the program is being ready for public use.</p>

<h2>Notation</h2>
<p>This section describes the notation used to document the language.</p>

<table>
<tr> <th>Concept</th> <th>Example</th> <th>Remark</th> </tr>
<tr> <td>Example code</td> <td><inline>[stroke pth head:someArrow]</inline></td> <td>No syntax highlighting of code elements.</td> </tr>
<tr> <td>Variable or state</td> <td><varname>stroke</varname>, <varname>•page</varname></td> <td></td> </tr>
<tr> <td>Replacable dito</td> <td><varname class="replacable">some_var</varname>, <varname class="replacable">•destination</varname></td> <td></td> </tr>
<tr> <td>Formal parameter name</td> <td><paramname>head</paramname></td> <td></td> </tr>
<tr> <td>Filename</td> <td><filename>hello.shape</filename></td> <td></td> </tr>
<tr> <td>Replacable dito</td> <td><filename class="replacable">filename.shape</filename></td> <td></td> </tr>
<tr> <td>Type name</td> <td><typename>Path2D</typename></td> <td>Not yet supported by the language.</td> </tr>
<tr> <td>Regular expression</td> <td><lexerregexp>[~]?[0-9]+([.][0-9]*)?</lexerregexp></td> <td>Like flex version 2.5.4, but generalized to UTF-8.</td> </tr>
<tr> <td>Syntax rule name</td> <td><syntaxname>call-expr</syntaxname></td> <td></td> </tr>
<tr> <td>BNF structure</td> <td><bnf>?</bnf></td> <td></td> </tr>
</table>

<p>In the BNF notation, entities separated by whitespace matches source code possibly separated by whitespace.  However, there is sometimes a need to indicate that whitespace is not allowed.  This can be done by simply omitting the whitespace from the BNF notation, but if this is impossible for readability reasons, the special BNF syntax <bnf>;</bnf> will be used, like this: <inline><syntaxname>basicf-float</syntaxname><bnf>;</bnf><syntaxname>unit</syntaxname></inline>.  Conversely, mandatory whitespace is denoted <bnf>_</bnf>, which will be surrounded by ordinary whitespace for readability.</p>

<p>To denote that a piece of syntax allows expression that evaluate to a certain type, the <bnf>::</bnf> notation is used, like this:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">float</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Float</typename></td></tr>
</table>

<p>It is also possible to indicate expressions that evaluate to a valua of a given type, using the notation <inline><bnf>&lt;</bnf><typename class=replacable>SomeType</typename><bnf>&gt;</bnf></inline>, like this:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">float-pair</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( <bnf>&lt;</bnf><typename>Float</typename><bnf>&gt;</bnf>, <bnf>&lt;</bnf><typename>Float</typename><bnf>&gt;</bnf> )</inline></td></tr>
</table>

<p>The following character classes will be used later:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">LowerCaseLetter</syntaxname></td> <td><bnf>→</bnf></td> <td><lexerregexp>[a-z_?π§]</lexerregexp></inline></td></tr>
<tr> <td><syntaxname class="new">UpperCaseLetter</syntaxname></td> <td><bnf>→</bnf></td> <td><lexerregexp>[A-Z]</lexerregexp></inline></td></tr>
<tr> <td><syntaxname class="new">Letter</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>LowerCaseLetter</syntaxname> <bnf>|</bnf> <syntaxname>UpperCaseLetter</syntaxname></inline></inline></td></tr>
</table>


<h1>Files</h1>
<p>Before going into the language itself, let us introduce a few definitions relating to files.</p>

<p>When the compiler is invoked, this shall typically result in a piece of graphics.  This is the <em>output</em> file.</p>

<p>Two types of input files can be identified.  First, there are <em>application sources</em>, which are generally used to create a corresponding piece of graphics in an output file.  (Sometimes, an application source may not be meant to produce an output file by itself, but as part of another application where it is included.)  Second, there are <em>extension sources</em>, which shall not produce any graphics by themselves, but only provide functionality that can be used in applications.</p>

<p>There are other types of files as well, but the introduction of these is not needed for the language reference.</p>


<h1>Syntax</h1>
<p>Here, term <em>syntax</em> basically refers to everything that does not have to do with the values bound to variables in the initial environments.  Most importantly, the library functions (or <em>preamble</em>, or <em>standard procedures</em>, et&nbsp;c) are not included here.</p>

<p>It might be confusing, though, to find that many of the composite expression syntaxes are implemented as function calls, which the user may become aware of when encoutering certain error messages.</p>

<h2>File inclusion and comments</h2>
<p>These are two very basic functions of the scanner, and have in common that they have nothing to do with the <em>meaning</em> of program code, but only where (not) to <em>find</em> the code.</p>

<h3>File inclusion</h3>
<p>Files are included using the scanner directives <inline>##needs</inline> and <inline>##include</inline>.  The <inline>##needs</inline> directive is used to require extension sources to be loaded, and will only load each source once.  This avoids the duplicate definitions that would occur if the source was loaded several times at, say, the global scope.  It is strongly recommended not to use <inline>##needs</inline> but in the global scope.  The <inline>##include</inline> directive will load the source unconditionally, and is used with application sources (use with extension source may be permitted in the future).  The syntax is</p>
<pre>
##needs <filename class="replacable">filenamebase</filename> <bnf>(</bnf>: <bnf>_</bnf> <filename class="replacable">directory</filename><bnf>)?</bnf>
</pre>
<p>which <em>must appear at the beginning of a line</em> (note the mandatory whitespace after the colon).  The syntax for <inline>##include</inline> is analogous, like this:</p>
<pre>
##needs blockdraw
##needs book_settings : ~/Library/Shapes/Project Settings
##include background
##include foreground
</pre>
<p></p>

<p>Note that the <em>leading</em> whitespace is eaten up, while the whitespace in the directory name is kept.</p>

<h3>Comments</h3>
<p>Multi-line comments are delimited by <inline>/**</inline> and <inline>**/</inline>, and nest.  It is recommended that multi-line comments begin each line with <inline>**</inline>.  It is also recommended that no code is put on the same line as a multi-line comment, since it will be very hard for the eye to see what really is commented out.</p>

<p>Rest-of-line comments start with <inline>|**</inline>.</p>

<p>The designers of the C language may have a good point when they say that rest-of-line comments is the only type of comment to be used to comment out code.  Whether they think that rest-of-line comments may also be used for comments I don't know, but I think it would be a good idea to reserve the use of rest-of-line comments for only commenting out code, and to use multiline comments for comments (documentation).</p>

<h2>Atoms</h2>
<p>Here the different scanner tokens that directly define values are described.</p>

<h3>Floats</h3>
<table cellspacing="5">
<tr> <td><syntaxname>basic-float</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Float</typename></td></tr>
<tr> <td><syntaxname class="new">basic-float</syntaxname></td> <td><bnf>→</bnf></td> <td><lexerregexp>[~]?[0-9]+([.][0-9]*)?</lexerregexp></td></tr>
<tr> <td><syntaxname>float</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Float</typename></td></tr>
<tr> <td><syntaxname class="new">float</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>basic-float</syntaxname> <bnf>|</bnf> <syntaxname>basic-float</syntaxname>°</inline></td></tr>
</table>
<p>A float begins with an optional tilde sign which, when present, indicates that the number is negative.  Then follows one or more decimal digits, an optional decimal point, and finally an optional sequence of decimal digits.  A degree sign can be appended, effectively multiplying the preceding float by pi/180.  Examples are given below.</p>

<table cellspacing="5">
<tr> <td><b>Token</b></td> <td width="20"></td> <td><b>Valid float?</b></td> </tr>
<tr> <td><inline>13</inline></td> <td></td> <td>Yes (= 13)</td> </tr>
<tr> <td><inline>~13</inline></td> <td></td> <td>Yes (= -13)</td> </tr>
<tr> <td><inline>2.</inline></td> <td></td> <td>Yes (= 2.0)</td> </tr>
<tr> <td><inline>~3.14</inline></td> <td></td> <td>Yes (= -3.14)</td> </tr>
<tr> <td><inline>~180°</inline></td> <td></td> <td>Yes (= -3.14159...)</td> </tr>
<tr> <td><inline>.609</inline></td> <td></td> <td>No (missing integer part)</td> </tr>
<tr> <td><inline>-3.1</inline></td> <td></td> <td>No (binary minus sign)</td> </tr>
<tr> <td><inline>1 000</inline></td> <td></td> <td>No (spaces are not allowed)</td> </tr>
<tr> <td><inline>180 °</inline></td> <td></td> <td>No (space is not allowed)</td> </tr>
</table>
<p></p>

<p>An alternative way to create negative numbers is to use the unary negation expression, for example: <inline>(-3.1)</inline>.  However, note that the parentheses are mandatory, thus reducing readability compared to the tilde sign alternative.</p>

<h3>Lengths</h3>
<table cellspacing="5">
<tr> <td><syntaxname>length</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Length</typename></td></tr>
<tr> <td><syntaxname class="new">length</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>basic-float</syntaxname><bnf>;</bnf><syntaxname>length-unit</syntaxname></inline></td></tr>
</table>
<p>Length tokens are formed by a float (not ending with the degree sign) followed by the name of a length.  New lengths can be defined as multiples of existing ones, as long as all definitions agree.  Length definitions are evaluated by the program scanner, which makes them very efficient in use.  The effect of a length unit defined as a more complicated expression in existing lengths, say one centimeter plus one inch, must be simulated by storing the length in a variable, which is then multiplied with a float to denote a length in this new unit.</p>

<p>The following lengths are provided by the system: <lengthunit>mm</lengthunit>, <lengthunit>cm</lengthunit>, <lengthunit>m</lengthunit>, <lengthunit>bp</lengthunit> (big point, also called <em>PostScript point</em>), and <lengthunit>in</lengthunit>.</p>

<table cellspacing="5">
<tr> <td><b>Token</b></td> <td width="20"></td> <td><b>Valid length?</b></td> </tr>
<tr> <td><inline>2.5cm</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>2.5pt</inline></td> <td></td> <td>No (unless the unit <lengthunit>pt</lengthunit> is defined)</td> </tr>
<tr> <td><inline>~3mm</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>3 mm</inline></td> <td></td> <td>No (space not allowed)</td> </tr>
<tr> <td><inline>180°mm</inline></td> <td></td> <td>No (degree sign not allowed)</td> </tr>
</table>
<p></p>

<p>A new unit is defined using the following syntax, which must appear <em>at the beginning of a line</em>:</p>
<pre>
##unit <lengthunit class="replacable">new_unit</lengthunit> = <syntaxname>length</syntaxname>
</pre>
<p>The point used by TeX is taken as an example.  The new unit will be called <lengthunit>tex</lengthunit>:</p>
<pre>
##unit tex = 0.996264009963bp
</pre>

<h3>Special units of length</h3>
<p>Special units of lengths are used when constructing smooth paths.  Then, it is often desirable not to have to provide the distance to control points in terms of absolute distances, but one would rather specify the distance relative to the distance between the first and final interpolation point, and the angles from the first and final interpolation points to the intermediate control points.</p>

<p>The most frequent use of special units of lengths is to assign the dynamic variable <varname>@defaultunit</varname>, see <a href="#pathconstruction">path construction</a>.</p>

<p>Special lengths can be viewed as a function taken from a particular (parameterized) set of functions.  There are only eight special units of lengths, and currently, there is no support for defining new ones.  Here is the list of them all:</p>
<table cellspacing="5">
<tr align="left"> <th>Name</th> <th>Distance</th> <th>No inflexion</th> <th>Circelish</th> <th>Correction</th> </tr>
<tr> <td><lexerregexp>%[D0]</lexerregexp></td> <td>√</td> <td></td> <td></td> <td></td> </tr>
<tr> <td><lexerregexp>%[C1]</lexerregexp></td> <td>√</td> <td></td> <td>√</td> <td></td> </tr>
<tr> <td><lexerregexp>%[M2]</lexerregexp></td> <td>√</td> <td></td> <td></td> <td>√</td> </tr>
<tr> <td><lexerregexp>%[F3]</lexerregexp></td> <td>√</td> <td></td> <td>√</td> <td>√</td> </tr>
<tr> <td><lexerregexp>%[d4]</lexerregexp></td> <td>√</td> <td>√</td> <td></td> <td></td> </tr>
<tr> <td><lexerregexp>%[c5]</lexerregexp></td> <td>√</td> <td>√</td> <td>√</td> <td></td> </tr>
<tr> <td><lexerregexp>%[m6]</lexerregexp></td> <td>√</td> <td>√</td> <td></td> <td>√</td> </tr>
<tr> <td><lexerregexp>%[f7]</lexerregexp></td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> </tr>
<tr> <td><lexerregexp>%[i9]</lexerregexp></td> <td></td> <td>√</td> <td></td> <td></td> </tr>
</table>
<p>The meaning of the columns is the following.  If there is a check mark in the <em>Distance</em> column, then the distance between the first and last interpolation point is used as a base length.  If there is a check mark in the <em>Circelish</em> column, then the base length is multiplied by a factor based on the near angle, in such a way that circles are approximated well.  If there is a check mark under <em>Correction</em>, a correction factor is applied based on the difference between the near angle and the far angle; if both angles are the same, there is no correction.  If there is a check mark in the <em>No inflexion</em> column, then the distance to the intermediate control point is truncated to avoid inflexions, if necessary.  The unit which is not based on the distance between the first and last interpolation point is based on the inflexion limit instead.</p>
<remark>
<p>I know that the description of the special lengths is really bad.  I hope it will be better once I start documenting path construction in general.</p>
</remark>

<p>For instance, the following approximates a quarter of a circle well:</p>
<pre>
•page << [stroke (0cm,1cm)>(1%C^0°)--(1%C^90°)<(1cm,0cm)]
</pre>

<h3>Strings</h3>
<p>The string syntax in Shapes is fairly non-standard.  However, it needs to be so to allow TeX strings to be entered as plain as possible.</p>

<p>Strings are delimited by the grave and acute accent, respectively.  Each delimiter can be extended to include a newline character on the inside.  Other newlines are part of the string literal.  The delimiting accents (no optional newlines this time) nest.  The escape character is <inline>¢</inline> (the cent sign), and the possible escape sequences are given below:</p>

<table cellspacing="5">
<tr align="left"> <th>Escape sequence</th> <td width="20"></td> <th>Resulting character</th> </tr>
<tr> <td><inline>¢¢</inline></td> <td></td> <td>¢</td> </tr>
<tr> <td><inline>¢`</inline></td> <td></td> <td>`</td> </tr>
<tr> <td><inline>¢´</inline></td> <td></td> <td>´</td> </tr>
<tr> <td><inline>¢n</inline></td> <td></td> <td>(a newline)</td> </tr>
<tr> <td><inline>¢t</inline></td> <td></td> <td>(a tab character)</td> </tr>
</table>
<p></p>

<p>It is recommended that strings are entered in one of two ways among all ways to deal with newline characters.  The first alternative is to enter newlines literally and using the optional newlines at the delimiters.  The other alternative, of course, is to skip the newlines at the delimiters and replace all newlines in the literal by the corresponding escape sequence.  See the following examples:</p>

<table cellspacing="5">
<tr align="left"> <th>Token</th> <td width="20"></td> <th>Valid string?</th> </tr>
<tr> <td><inline>`Hi there´</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>`Shapes string: `Hi there´´</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>`Boing!¢b´</inline></td> <td></td> <td>No (no such escape sequence)</td> </tr>
<tr> <td><inline>`Quasiquotation: `(0 1 ,(1+1))´</inline></td> <td></td> <td>No (Unbalanced delimiter)</td> </tr>
<tr> <td><inline>`Quasiquotation: ¢`(0 1 ,(1+1))´</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>`Here's a formula: $(1+x)^{2}$´</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>`Dear Shaper¢n¢nMulti-line...´</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><pre>
`
Dear Shaper,

Multi-line...
´
</pre></td> <td></td> <td>Yes</td> </tr>
<tr> <td><pre>
`Dear Shaper,

Multi-line...´
</pre></td> <td></td> <td>Yes, but not recommended</td> </tr>
</table>
<p></p>

<h3>Booleans</h3>
<table cellspacing="5">
<tr> <td><syntaxname>boolean</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Boolean</typename></td></tr>
<tr> <td><syntaxname class="new">boolean</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>true <bnf>|</bnf> false</inline></td></tr>
</table>

<p>The valid Booleans are listed below.</p>
<table cellspacing="5">
<tr align="left"> <th>Token</th> <td width="20"></td> <th>Valid Boolean?</th> </tr>
<tr> <td><inline>false</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>true</inline></td> <td></td> <td>Yes</td> </tr>
</table>
<p></p>

<h3>Integers</h3>
<p>Integers are entered with radix 10, 16, or 2, and begin with an apostrophe.  The tilde sign is placed after the apostrophe for negative values, and is only allowed with radix 10.  Examples:</p>

<table cellspacing="5">
<tr align="left"> <th>Token</th> <td width="20"></td> <th>Valid Integer?</th> </tr>
<tr> <td><inline>'13</inline></td> <td></td> <td>Yes (= 13)</td> </tr>
<tr> <td><inline>'~5</inline></td> <td></td> <td>Yes (= -5)</td> </tr>
<tr> <td><inline>'0xFF</inline></td> <td></td> <td>Yes (= 255)</td> </tr>
<tr> <td><inline>'0b110</inline></td> <td></td> <td>Yes (= 6)</td> </tr>
<tr> <td><inline>'~0xFF</inline></td> <td></td> <td>No (negative integers must be entered with radix 10)</td> </tr>
<tr> <td><inline>(-'0xFF)</inline></td> <td></td> <td>Yes, but this is an expression, not a token.</td> </tr>
</table>
<p></p>

<h3>Identifiers</h3>
<table cellspacing="5">
<tr> <td><syntaxname class="new">identifier</syntaxname></td> <td><bnf>→</bnf></td> <td><lexerregexp>{LowerCaseLetter}({Letter}|[0-9])*</lexerregexp></td></tr>
</table>
<p>Although identifiers <em>by themselves</em> do not denote values, they are introduced here since they are needed in the definition of symbols below.</p>

<p>An identifier is made up by one or more of the characters a-z, A-Z, 0-9, the underscore, and the question mark.  However, it must not begin with a number, and if it begins by the underscore, the second character must not be a number.  As of today, identifiers may neither begin with a capital letter.  Instead, a capital letter indicates a type name.</p>

<table cellspacing="5">
<tr> <td><b>Token</b></td> <td width="20"></td> <td><b>Valid identifier?</b></td> </tr>
<tr> <td><inline>cool?</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>a_1_2</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>__cplusplus</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>3cm</inline></td> <td></td> <td>No (this begins with a digit and is a length)</td> </tr>
<tr> <td><inline>_3abc</inline></td> <td></td> <td>No (digit after underscore in first position)</td> </tr>
</table>
<p></p>

<h3>Dynamic variables</h3>
<table cellspacing="5">
<tr> <td><syntaxname class="new">dyn-var</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><lexerregexp>@</lexerregexp><syntaxname>identifier</syntaxname></inline></td></tr>
</table>

<h3>State references</h3>
<p>Note that state references are not expressions.</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">state</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>lex-state</syntaxname> <bnf>|</bnf> <syntaxname>dyn-state</syntaxname></inline></td></tr>
<tr> <td><syntaxname class="new">lex-state</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><lexerregexp>[•#]</lexerregexp><syntaxname>identifier</syntaxname></inline></td></tr>
<tr> <td><syntaxname class="new">dyn-state</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><lexerregexp>@[•#]</lexerregexp><syntaxname>identifier</syntaxname></inline></td></tr>
</table>


<h3>Symbols</h3>
<table cellspacing="5">
<tr> <td><syntaxname>symbol</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Symbol</typename></td></tr>
<tr> <td><syntaxname class="new">symbol</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>'<syntaxname>identifier</syntaxname></inline></td></tr>
</table>
<p>Note that there must not be any whitespace after the apostrophe.</p>

<p>Symbols are entered as the apostrophe followed by an identifier.
<table>
<tr> <td><b>Token</b></td> <td width="20"></td> <td><b>Valid symbol?</b></td> </tr>
<tr> <td><inline>'foo</inline></td> <td></td> <td>Yes</td> </tr>
<tr> <td><inline>'2dup</inline></td> <td></td> <td>No (<inline>2dup</inline> is not an identifier)</td> </tr>
<tr> <td><inline>'28</inline></td> <td></td> <td>No, this is an integer</td> </tr>
</table>
<p></p>


<h2>Compound syntax constructors</h2>
<p>This section describes syntax that denotes value construction in terms of other values and expressions, whithout doing so via a usual function call.  Values that are constructed by calling a library function are described elsewhere.  As an exception, class construction is not defined here either.</p>

<h3>Float pairs and triples</h3>

<table cellspacing="5">
<tr> <td><syntaxname>float-pair</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>FloatPair</typename></td></tr>
<tr> <td><syntaxname class="new">float-pair</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( <bnf>&lt;</bnf><typename>Float</typename><bnf>&gt;</bnf>, <bnf>&lt;</bnf><typename>Float</typename><bnf>&gt;</bnf> )</inline></td></tr>
<tr> <td><syntaxname>float-triple</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>FloatTriple</typename></td></tr>
<tr> <td><syntaxname class="new">float-triple</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( <bnf>&lt;</bnf><typename>Float</typename><bnf>&gt;</bnf>, <bnf>&lt;</bnf><typename>Float</typename><bnf>&gt;</bnf>, <bnf>&lt;</bnf><typename>Float</typename><bnf>&gt;</bnf> )</inline></td></tr>
</table>

<p>Float pairs and triples are useful generalizations of directions in 2D and 3D, and may serve other purposes as well.  The way they generalize directions is that they can be multiplied by a length to yield coordinates.  The drawback of using these objects to represent directions, of course, is that the origin is a valid value, but does not represent a direction.  However, it is believed that the inconvenience of having to keep apart diractions and pairs/triples whould overshadow the conceptual and type safety winnings.  (Internal computations, however, do keep directions and pairs/triples apart.)</p>

<p>The syntax for constructing pairs and triples is to separate the floats by commas, and enclose it all in parentheses.  The following table gives a few examples.</p>

<table cellspacing="5">
<tr> <td><b>Expression</b></td> <td width="20"></td> <td><b>Valid construct?</b></td> </tr>
<tr> <td><inline>( 5, 7 )</inline></td> <td></td> <td>Yes, yields a float pair</td> </tr>
<tr> <td><inline>( 1.2, 3.4, 5 )</inline></td> <td></td> <td>Yes, yields a float triple</td> </tr>
<tr> <td><inline>( 5, '7 )</inline></td> <td></td> <td>No, <inline>'7</inline> is an integer</td> </tr>
</table>
<p></p>

<h3>Offsets</h3>
<p>Sometimes, the context defines an alternative base point than can define the meaning of coordinates.  To make a difference between coordinates that are relative the usual origin and the context-defined base point, the former coordinates are referred to as <em>offsets</em>, constructed using the unary plus operator:</p>
<table cellspacing="5">
<tr> <td><syntaxname>offset</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>OffsetLength</typename></td></tr>
<tr> <td><syntaxname class="new">offset</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( + <bnf>&lt;</bnf><typename>Length</typename><bnf>&gt;</bnf> )</inline></td></tr>
<tr> <td><typename>LengthLike</typename></td> <td><bnf>=</bnf></td> <td><inline> <typename>Length</typename> | <typename>OffsetLength</typename></inline></td></tr>
</table>

<h3>Coordinates in 2D and 3D</h3>
<p>In this context, 2D and 3D refer to the perceivable space (3D) and plane (2D).  Coordinates are never explicitly associated with a base frame, which would imply that coordinates denoted a particular point in the perceivable spaces.  Rather, coordinates are always relative, possibly with the exception of when graphics are laid out on the output plane.  However, even when graphics are placed on the output plane, they remain relative to an artificial origin, and this is particularly obvious when the output's media box is determined <em>after</em> the contents of the output has been laid out.</p>

<p>That said, we can drop the distinction of the two types of coordinates, and it is, for example, always permissible to add coordinates.  The basic way to construct coordinates is similar to how pairs/triples are constructed, but with lengths instead of floats.  One notable exception to this rule is that if one of the lengths in 2D are zero, it may be given as the <em>float</em> zero.  Coordinates may also be constructed as relative an undetermined base frame, please refer to the documentation on path construction for how the base frame may be determined later.</p>

<p>The unary plus may be used either to construct offsets on a per-dimension level, or on a complete coordinates expression.</p>

<p>The following table below lists the valid constructs.</p>
<table cellspacing="5">
<tr> <td><syntaxname>coords-2D</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Coord2D</typename></td></tr>
<tr> <td><syntaxname class="new">coords-2D</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( <bnf>&lt;</bnf><typename>LengthLike</typename><bnf>&gt;</bnf>, <bnf>&lt;</bnf><typename>LengthLike</typename><bnf>&gt;</bnf> )</inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline>( 0 , <bnf>&lt;</bnf><typename>LengthLike</typename><bnf>&gt;</bnf> )</inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline>( <bnf>&lt;</bnf><typename>LengthLike</typename><bnf>&gt;</bnf>, 0 )</inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline>( + <syntaxname>coords-2D</syntaxname> )</inline></td></tr>
<tr> <td><syntaxname>coords-3D</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Coord3D</typename></td></tr>
<tr> <td><syntaxname class="new">coords-3D</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( <bnf>&lt;</bnf><typename>LengthLike</typename><bnf>&gt;</bnf>, <bnf>&lt;</bnf><typename>LengthLike</typename><bnf>&gt;</bnf>, <bnf>&lt;</bnf><typename>LengthLike</typename><bnf>&gt;</bnf> )</inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline>( + <syntaxname>coords-3D</syntaxname> )</inline></td></tr>
</table>

<p>Some examples are given in the table below.</p>

<table cellspacing="5">
<tr> <td><b>Expression</b></td> <td width="20"></td> <td><b>Valid construct?</b></td> </tr>
<tr> <td><inline>( 5cm, 7in )</inline></td> <td></td> <td>Yes, yields coordinates in the perceivable plane</td> </tr>
<tr> <td><inline>( 5cm, 0 )</inline></td> <td></td> <td>Yes, same as <inline>( 5cm, 0m )</inline></td> </tr>
<tr> <td><inline>( 0, 7bp )</inline></td> <td></td> <td>Yes, same as <inline>( 0m, 7bp )</inline></td> </tr>
<tr> <td><inline>( 2mm, 7mm, 5mm )</inline></td> <td></td> <td>Yes, yields coordinates in the perceivable space</td> </tr>
<tr> <td><inline>( 2mm, 0, 5mm )</inline></td> <td></td> <td>No, the float zero is only allowed in 2D</td> </tr>
<tr> <td><inline>( (+0mm), 1mm ))</inline></td> <td></td> <td>Yes, the x component is relative an undetermined base frame</td> </tr>
<tr> <td><inline>(+ ( 1cm, 1mm ))</inline></td> <td></td> <td>Yes, same as <inline> ( (+1cm), (+1mm) ))</inline></td> </tr>
<tr> <td><inline>(+ 3mm*[dir 20°])</inline></td> <td></td> <td>Yes, same as <inline>( (+ (3mm*[dir 20°]).x), (+ (3mm*[dir 20°]).y) )</inline></td> </tr>
<tr> <td><inline>( (+0mm), 1mm, (+7mm) )</inline></td> <td></td> <td>Yes, relative coordinates may be used in both 2D and 3D</td> </tr>
</table>
<p></p>


<h3>Functions and friends</h3>
<p>Functions are at the heart of a functional language.  Powerful ways of creating functions make source code both more compact and more comprehensible.  The language is <em>not</em> curried, but contains many constructs to support <em>evaluated cuts</em>, but these are presented in connection with <a href="#funapply">function calls</a>.</p>

<p>There are true (pure) functions, non-pure functions, and horrible procedures, all of which are constructed similarly, but differ in how they are applied and what they are allowed to do.  First, pure functions will be discussed in detail.  Then, non-pure functions and procedures will be presented in terms of how they differ from pure functions.</p>

<p>Let us begin with a very simple example, the hypothenuse function (never mind that there is dedicated syntax for this in the language already):</p>
<pre>
\ x y .> [sqrt x*x + y*y]
</pre>
<p>This fits into (note that there is only a small difference between the syntax for functions and procedures)</p>
<table cellspacing="5">
<tr> <td><syntaxname>function</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Function</typename></td></tr>
<tr> <td><syntaxname class="new">function</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>\ <bnf>(</bnf> <bnf>(</bnf> <syntaxname>identifier</syntaxname> <syntaxname>default</syntaxname><bnf>?</bnf> <bnf>)</bnf> <bnf>|</bnf> <syntaxname>state-identifier</syntaxname> <bnf>)*</bnf> <syntaxname>sink</syntaxname><bnf>?</bnf> .> <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td><syntaxname>procedure</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>Procedure</typename></td></tr>
<tr> <td><syntaxname class="new">function</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>\ <bnf>(</bnf> <bnf>(</bnf> <syntaxname>identifier</syntaxname> <syntaxname>default</syntaxname><bnf>?</bnf> <bnf>)</bnf> <bnf>|</bnf> <syntaxname>state-identifier</syntaxname> <bnf>)*</bnf> <syntaxname>sink</syntaxname><bnf>?</bnf> .> ! <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td><syntaxname class="new">default</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>: <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td><syntaxname class="new">sink</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>&lt;&gt; <syntaxname>identifier</syntaxname></inline></td></tr>
</table>

<p>The semantic difference between a procedure and a function is that the body expression of a procedure have access to states residing outside the body.</p>

<p>A function with a sink can take any number of arguments, and arguments by any name.  Everything that does not match the list of formals before the sink is placed in the sink, which is a <a href="#structures">structure</a>.</p>

<h3><a name="structures">Structures</a></h3>
<p>Structures allows values to be grouped into a composite value, from which the components can later be extracted.  The mechanism for this is designed to remind as much as possible of how multiple values are passed to a function during a function call.  This creates some useful analogies.  Please refer to <a href="#funapply">function application</a> for an explanation of <syntaxname>named-expr</syntaxname>, and to see how structures may be used.</p>

<table cellspacing="5">
<tr> <td><syntaxname>structure</syntaxname></td> <td><bnf>::</bnf></td> <td>&ldquo;<typename>Structure</typename>&rdquo;</td></tr>
<tr> <td><syntaxname class="new">structure</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>(&gt; <syntaxname>expr</syntaxname><bnf>*</bnf> <syntaxname>named-expr</syntaxname><bnf>*</bnf> &lt;)</inline></td></tr>
</table>

<p>Note that the type of a structure is a complex type, which we don't bother to write out here.</p>

<p>Besides getting parts out of a structure by applying a function to it, it is possible to bind to multiple values in the structure at once.  The syntax is</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">split-define</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>(< <bnf>(</bnf> <syntaxname>split-item</syntaxname> <syntaxname>default</syntaxname><bnf>?</bnf> <bnf>)+</bnf> <syntaxname>sink</syntaxname><bnf>?</bnf> >) : <bnf>&lt;</bnf><typename>Structure</typename><bnf>&gt;</bnf></inline></td></tr>
<tr> <td><syntaxname class="new">split-item</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>identifier</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>identifier</syntaxname> : . <syntaxname>identifier</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>identifier</syntaxname> : . &quot;</inline></td></tr>
</table>
<p>The semantics reminds of a function can, but there are differences.  Most importantly, the created bindings populate the <em>current</em> environment, rather than a new one.  The first (or only) identifier in the <syntaxname>split-item</syntaxname> is the identifier for the created binding.  There are ordered as well as named items; ordered items match ordered components in the structure, while named items match named components in the structure.  The ordered items are those with just one identifier.  When there are two identifiers, the latter is the name to be sought in the structure.  When there is a quotation mark (<inline>&quot;</inline>) instead of a second identifier, this means that the first identifier shall be used also as a second identifier.</p>

<p>Unlike a function application, ordered and named items do not interact; a named item cannot get its value from an ordered component in the structure.  As an example, this confusing code is not legal:</p>
<pre class="bad">
s: (> '9 <)
(< foo:bar >) : s
</pre>
<p>inspite the fact that the following <em>is</em> legal:</p>
<pre>
{
  s: (> '9 <)
  f: \ bar .> { foo:bar  foo }
  f [] <> s
}
</pre>

<p>Named parts can also be accessed by an ordinary field reference, like this:</p>
<pre>
s: (> a:'1  b:'2 <)
•stdout << s.b
</pre>

<exampleswitch>Show example!</exampleswitch>
<div class="closedexample" id="example-structures">
<pre>
<!--#include virtual="../../examples/features/values.drool" -->
</pre>
</div>

<h2><a name="funapply">Function application and evaluated cuts</a></h2>
<p>The basic syntax for applying (or <em>calling</em>) functions is borrowed from the Scheme language.  However, there is a predefined set of operators with fixed priorities that allow exceptions to this rule.  In addition, special syntax is used when a function is applied over a structure, and there is syntactic sugar for calling functions of just one argument.  A similar operation to calling a function is to define a new function by providing values for only some of the arguments — this is referred to as an <a href="http://srfi.schemers.org/srfi-26/srfi-26.html"><em>evaluated cut</em></a>.</p>

<h3>Basic function application</h3>
<p>Besides ordinary functions, there are some other objects which the function calling syntax accepts.  The other possible types of objects are affine transforms (which <em>should</em> behave just as functions of a single geometric object), and paths (which can accept a path time or an arctime).  The general form of a function application is</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">basic-call</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>[ <bnf>&lt;</bnf><typename>Applicable</typename><bnf>&gt;</bnf> <bnf>(</bnf> <syntaxname>arg-item</syntaxname> <bnf>|</bnf> <syntaxname>state-item</syntaxname> <bnf>)*</bnf> ]</inline></td></tr>
<tr> <td><syntaxname class="new">arg-item</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>expr</syntaxname> <bnf>|</bnf> <syntaxname>named-expr</syntaxname></inline></td></tr>
<tr> <td><syntaxname class="new">named-expr</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>identifier</syntaxname> : <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td><syntaxname class="new">state-item</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>state</syntaxname> <bnf>|</bnf> <syntaxname>named-state</syntaxname></inline></td></tr>
<tr> <td><syntaxname class="new">named-state</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>identifier</syntaxname> : <syntaxname>state</syntaxname></inline></td></tr>
<tr> <td><typename>Applicable</typename></td> <td><bnf>=</bnf></td> <td><typename>Function</typename> <bnf>|</bnf> <typename>AffineTransform</typename> <bnf>|</bnf> <typename>Path</typename></td> </tr>
</table>

<p>The syntax <syntaxname>arg-item</syntaxname> and <syntaxname>state-item</syntaxname> defined above can each be either <em>ordered</em> (that is, not named) or <em>named</em>, but there is a rule for how these may be ordered.  The rule exist to avoid confusing situations; not because it is necessary to define the semantics.  The rule is that ordered arguments (represented by <syntaxname>expr</syntaxname>) must go before named arguments (represented by <syntaxname>named-expr</syntaxname>), and ordered states (represented by <syntaxname>state</syntaxname>) before named states (represented by <syntaxname>named-state</syntaxname>).</p>

<remark>
<p>Of the conceivable semantics that could be defined if named arguments were allowed to appear before ordered arguments were allowed, two will be ruled out here.  First, one could simply ignore the order of appearance, and treat all named arguments just as if they appeared after the ordered arguments.  This would obscure the actual position of ordered arguments without adding any power to the language.  Second, one could add some power to the language by interpreting the position of ordered arguments in view of what unbound arguments there are, given the named and ordered arguments seen so far in a left to right scan.  However, such semantics would also obscure the actual position of ordered arguments severely.</p>
</remark>

<p>Arguments and states may appear in any order, since they do not interact at all.</p>

<p>It is not allowed to specify the same argument or state more than once by name.</p>

<p>Recall that the formal parameters of a function is an ordered list where each element has a name (with some exceptions).  To define the semantics of a function call, it must be described how items in the application is mapped to formal parameters.  Let us first consider the passing of arguments (as opposed to states).  First, the ordered arguments in the application are mapped to the corresponding positions in the list of formal parameters.  Then, the formal parameters which have not been specified by ordered arguments may be addressed by named arguemnts.  Finally, default values are used for formal parameters which are still unassigned.  It is an error if an unassigned formal parameter has no default value.</p>

<p>It is an error if there are too many arguments or if a named argument does not match the name of any formal parameter, unless the function has a sink.</p>

<p>The semantics for passing states is analogous to that of passing arguments.</p>

<p>The evaluation of argument expressions is typically delayed by passing a thunk instead of a value unless the argument is immediate or the corresponding formal parameter requires the argument to be forced.  (Most elementary functions in the kernel will require all their arguments to be forced, while user-defined functions only take thunks by default.)</p>

<h3>Procedure application</h3>
<p>The general form of a procedure application is</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">proc-call</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>[ ! <bnf>&lt;</bnf><typename>Procedure</typename><bnf>&gt;</bnf> <bnf>(</bnf> <syntaxname>arg-item</syntaxname> <bnf>|</bnf> <syntaxname>state-item</syntaxname> <bnf>)*</bnf> ]</inline></td></tr>
</table>
<p>Here, <syntaxname>fun-expr</syntaxname> is simply an expression that evaluates to a procedure.  Recall that a procedure may access dynamic states, so the exclamation mark that is part of the syntax is necessary to indicate that evaluation of the procedure application may have side-effects in case no states are being passed.  Besides this difference, the semantics are the same as that of a function application.</p>

<h3>Unary function application</h3>
<p>To apply a function to a single argument, one may use</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">unary-call</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><bnf>&lt;</bnf><typename>Applicable</typename><bnf>&gt;</bnf> [] <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><bnf>&lt;</bnf><typename>Applicable</typename><bnf>&gt;</bnf> [] <syntaxname>named-expr</syntaxname></inline></td></tr>
</table>
<p>Note that the <inline>[]</inline> must be written as a single token without whitespace between the brackets.  There is no corresponding sugar for passing states or applying procedures.</p>

<p>Postfix alternatives for unary application may be introduced in the future.</p>

<h3>Structures in function application</h3>
<p>Structures are special values that contain ordered as well as named components.  Applying a function to a structure has the same semantics as if the ordered and named components were split in a basic function application.  The syntax for calling a function with a structure is:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">split-call</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><bnf>&lt;</bnf><typename>Applicable</typename><bnf>&gt;</bnf> [] &lt;&gt; <bnf>&lt;</bnf><typename>Structure</typename><bnf>&gt;</bnf></inline></td></tr>
</table>
<p>Note that the <inline>[]</inline> and <inline>&lt;&gt;</inline> must each be written as a single token without whitespace.</p>

<h3>Basic evaluated cuts</h3>
<p>The syntax for the basic evaluated cut is simple:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">basic-cute</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>[ <bnf>&lt;</bnf><typename>Function</typename><bnf>&gt;</bnf> <syntaxname>expr</syntaxname><bnf>*</bnf> <syntaxname>named-expr</syntaxname><bnf>*</bnf> ... ]</inline></td></tr>
</table>
<p>Note that states cannot be bound in evaluated cuts, since this would store a reference to the state in a manner that does not match a functional language.  Also note that, as in function application, ordered arguments must be passed before named arguments.</p>

<p>The semantics of the evaluated cut may not be quite as everone expects.  Ordered arguments are simply mapped to the corresponding positions in the callee's list of formal parameters, and are bound without possibility to override in the evaluated cut.  Named arguments, however, are not actually bound to the addressed formal parameters, but only assigns (or replaces) the default value for that parameter.  Hence, named arguments in the evaluated cut are possible to override.</p>

<p>Note that it is a bad idea to use ordered arguments with a function whose list of formal parameters is unavailable for inspection.  It is such a bad idea that it would be pointless at best to allow named arguments to bind permanentally to a formal parameter in an evaluated cut, since the use of this would be to change the positions of ordered arguments in an obscure way.</p>

<h3>Unary evaluated cuts</h3>
<p>The following allows evaluated cuts to be constructed as easy as an unary function application:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">unary-cute</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><bnf>&lt;</bnf><typename>Function</typename><bnf>&gt;</bnf> [...] <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><bnf>&lt;</bnf><typename>Function</typename><bnf>&gt;</bnf> [...] <syntaxname>named-expr</syntaxname></inline></td></tr>
</table>
<p>Note that the <inline>[...]</inline> must be written as a single token without whitespace.</p>

<h3>Structures and evaluated cuts</h3>
<p>The syntax to use a structure for an evaluated cut is</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">split-cute</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><bnf>&lt;</bnf><typename>Function</typename><bnf>&gt;</bnf> [...] &lt;&gt; <bnf>&lt;</bnf><typename>Structure</typename><bnf>&gt;</bnf></inline></td></tr>
</table>

<h2>Code bracket</h2>
<p>The code bracket is a rather complicated kind of expression.  It is the home of many program elements, and its sementics is defined to avoid unnecessary nesting of scoping constructs.  The general form is</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">code-bracket</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>{ <syntaxname>bracket-item</syntaxname><bnf>*</bnf> }</inline></td></tr>
<tr> <td><syntaxname class="new">bracket-item</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>variable-definition</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>splicing-definition</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>state-item</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>dynamic-variable-declaration</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>dynamic-state-declaration</syntaxname></inline></td></tr>
</table>

<p>The top level semantics of the code brackets is defined by two phases.  In the first phase, all items in the bracket that can be evaluated at any time and without evaluation of sub-expressions, are evaluated.  This includes variable definitions whose right hand side can be delayed using a thunk.  Any items related to states are excluded from this phase.</p>

<p<>In the second phase, the remaining items are evaluated in order of appearance.  The value of the last item is used as the value of the whole code bracket.</p>

<p>It is an error to place a pure expression (that is one which does not interact with states) anywhere but at the end of the code bracket.  See <a href="#expressions">expressions</a> for the details of pure and non-pure expressions.</p>

<h3>Variable definitions</h3>
<table cellspacing="5">
<tr> <td><syntaxname class="new">variable-definition</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>identifier</syntaxname> : <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>identifier</syntaxname> : <syntaxname>lex-state</syntaxname> ;</inline></td></tr>
</table>
<p>The latter form is at the same time a kind of state item, and as such it is always evaluated in the second phase of the code bracket evaluation..</p>

<p>The semantics of the variable definitions is simple.  Bind the the variable to the value of expression, or freeze the state and bind to the final value of the state.  The former form is delayed unless the expression in the right hand side is immediate (see <a href="#laziness">laziness control</a>) or involves states or procedure applications.</p>

<h3>State items</h3>

<table cellspacing="5">
<tr> <td><syntaxname class="new">state-item</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>lex-state</syntaxname> : <bnf>&lt;</bnf><typename>Hot</typename><bnf>&gt;</bnf></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>state</syntaxname> <bnf>(</bnf> &lt;&lt; <syntaxname>expr</syntaxname> <bnf>)+</bnf>  </inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>lex-state</syntaxname> ;</inline></td></tr>
</table>
<p>The state items are always evaluated in order of appearance in the code bracket (note also the special kind of variable definition involving a state).</p>

<p>The first form introduces a state.  It requires a value of the special type <typename>Hot</typename> in the right hand side.  Values of this type has the special ability to spawn fresh states.  Note that a value of type <typename>Hot</typename> will always spawn identical fresh states, since being a <em>value</em> it has no internal state of its own.  On the other hand, it never spawns the <em>same</em> state twice, so each state it spawns lives its own life.</p>

<p>The second form modifies the state.  Note that states may also be modified by <a href="#expressions">non-pure expressions</a>.  It evaluates the right hand side expressions in order of appearance, and lets the state <em>tack on</em> the resulting values.</p>

<p>The last form, denoted a <em>freeze</em>, prohibits future use of the state, and evaluates to the final value of the state.  It is used as the end of a code bracket to return the accumulated value of a sequential computation.</p>

<h3>Dynamic declarations</h3>

<table cellspacing="5">
<tr> <td><syntaxname class="new">dynamic-variable-declaration</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>dynamic <syntaxname>dyn-var</syntaxname> <bnf>&lt;</bnf><typename>Function</typename><bnf>&gt;</bnf> <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline>dynamic <syntaxname>dyn-var</syntaxname> <bnf>&lt;</bnf><typename>Function</typename><bnf>&gt;</bnf> dynamic <syntaxname>expr</syntaxname></inline></td></tr>
</table>
<p>To declare a dynamic variable one needs to provide a <em>filter</em> and a top level value.  The filter is applied to each new value the dynamic variable is bound to, and is primarily indended for type and range checks, but may also be used to transform values before they are actually bound.  The filter must be a function of one argument.  The top level value is the value of the dynamic variable until it is changed further down in the dynamic environment.  The top level value is <em>not</em> passed through the filter.</p>

<p>A dynamic variable may also be bound to a dynamic expression at the top level, and this is obtained using the second form of the declaration.</p>

<p>Typical dynamic variable declarations may not care about the possibility to use the filter for type and range checks, and look like this:</p>
<pre>
dynamic @tex_bbox_grow_abs identity 1bp
dynamic @tex_bbox_grow_rel identity 1.01
</pre>
<p>A simple filter could look like this:</p>
<pre>
dynamic @tex_bbox_grow_rel
  \ new .>
    [if not [typeof new].isa[]Float
      [error `Type mismatch for @tex_bbox_grow_rel: required a Float.´]
      [if new <= 0
        [error `Out of range error for @tex_bbox_grow_rel: required a positive value.´]
        new]]
  1.01
</pre>

<p>Dynamic states is a language feature with subtleties.  At this time, they will not be further discussed.  Anyway, the syntax is:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">dynamic-state-declaration</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>dynamic <syntaxname>dyn-state</syntaxname> <syntaxname>state</syntaxname></inline></td></tr>
</table>


<h2>Bindings and scoping</h2>
<p>Shapes supports both lexical and dynamic bindings.  This section describe how to create such bindings, what their scopes are, and how to access the values of a binding.  Note that a binding can never be changed.</p>

<h3>Lexical binding</h3>
<p>A <em>lexical binding</em> is a variable whose definition can (easily) be found by a look at the source code.  Code brackets and functions play an essential role for the semantics here.</p>

<p>Lexical binding is perhaps most easily understood from an implementation point of view.  Whenever an expression is evaluated, the current lexical scope is defined by the <em>(lexical) environment</em>.  The environment has its own bindings, that is, mapping from some identifiers to values, and a parent environment (with the exception of the global environment, which has no parent).  When a lexical variable is evaluated, it is searched in the current environment, and if it is found, the variable evaluates to the value mapped to.  If the variable is not found, the search continues in the parent environment, and so forth.  If the search continues to the global environment, and fails there, it is an error; the variable is not bound.  To understand this process in more detail, one must understand where in the source code new environments are set up, and how they are populated with mappings from identifiers to values.</p>

<p>First, functions set up a new environment for the passed arguments when they are called.  The parent of the new environment is the environment that was in scope where the function was created (this is typically not the current environment where the function is called).  The body of the function is then evaluated in the new environment.  These rules simply ensure that the variables that were in scope were the function was created are also in scope when the body of the function is evaluated (except in case of shadowing).</p>

<p>A classic example of how lexical scoping works is the <varname>addn</varname> function:</p>
<pre>
addn: \ n .> \ x .> x + n
inc: [addn '1]
•stdout << [inc '3]
</pre>
<p>The above program prints the integer 4.  Note that <varname>n</varname> must be in scope when <inline>x + n</inline> is evaluated, even though <varname>n</varname> is not in scope where <varname>inc</varname> is invoked.  What is important is that <varname>n</varname> is in scope where the function bound to <varname>inc</varname> was created.</p>

<p>Second, every code bracket sets up a new environment, under the current environment.  The new environment is both home for bindings introduced in the code bracket, and becomes the current environment for the expressions evaluated in the code bracket.  This means that the following is a valid code bracket:</p>
<pre>
{
  a: '1
  b: a + '1
  b
}
</pre>
<p>So far, this seems similar to the semantics of <varname>let*</varname> in Scheme.  However, the following code bracket is equivalent:</p>
<pre>
{
  b: a + '1
  a: '1
  b
}
</pre>
<p>This reminds more of <varname>letrec</varname> in Scheme, but the reason it works has another explanation: laziness.  The variables <varname>b</varname> and <varname>a</varname> are bound to thunks before the expression <varname>b</varname> is evaluated.</p>

<p>It is possible to <em>reach out</em> from the current lexical scope to circumvent <em>shadowing</em> bindings.  The syntax for this is</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">reach-out</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>../ <syntaxname>expr</syntaxname></inline></td></tr>
</table>
<p>In theory, the semantics of this is simple; evaluate <syntaxname>expr</syntaxname> in the lexical environment which is the parent of the current lexical environment.  However, sometimes a deeper understanding of the language is required to see how many generations one must walk up the chain of environments to avoid a given binding.  On the other hand, with this problem in mind, empty environments are never optimized away.</p>

<p>As an example of reach out, suppose we regret how we defined the paramter <paramname>depth</paramname> long time ago.  Now we have to live with it since our function is part of a library with many users which we don't want to bother with the off-by-one change that would make our implementation of the function more natural.  The following is not an option, since the function may be called with named arguments:</p>
<pre class="bad">
\ off_by_one_depth .>
  {
    depth: off_by_one_depth - '1
    /**
     ** Rest of body.
     **/
  }
</pre>
<p>Of course, we could use a new name for the adjusted depth, but pretend we are really keen to use the name <paramname>depth</paramname>.  Then we could use a reach-out:</p>
<pre>
\ depth .>
  {
    /** Important!  We deal with the off-by-one mistake here, once and for all.
     **/
    depth: ../depth - '1

    /**
     ** Rest of body.
     **/
  }
</pre>
<p>Note that this changes the binding for <varname>depth</varname> in all of the code bracket, and hence it is a very good idea for readability to introduce the binding at the top of the code bracket.</p>


<h3>Dynamic binding</h3>
<p>The value of a <em>dynamic binding</em> is determined by the current <em>dynamic environment</em> and cannot be determined by a simple lexical analysis.  The dynamic environment is changed by the special construct</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">with-dynamic</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><bnf>&lt;</bnf><typename>DynamicBindings</typename><bnf>&gt;</bnf> | <syntaxname>expr</syntaxname></inline></td></tr>
</table>
<p>(Note that the vertical bar is not part of the BNF structure, but is the operator that indicates a change of dynamic scope.)</p>

<p>The semantics is simply that a new dynamic environment is set up under the current dynamic environment, and populated with the provided bindings.  So far, except that the bindings are provided though special values instead of by using special syntax, this is how code brackets work.  The difference is when it comes to functions.  Calling a function <em>does not</em> change the dynamic environment.  One can think of dynamic variables as a way of passing parameters to functions without explicitly providing them as arguments; the dynamic environment is always passed implicitly.</p>

<p>Dynamic bindings are constructed with the following syntax:</p>
<table cellspacing="5">
<tr> <td><syntaxname>dynamic-bindings</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>DynamicBindings</typename></td></tr>
<tr> <td><syntaxname>dynamic-binding</syntaxname></td> <td><bnf>::</bnf></td> <td><typename>DynamicBinding</typename></td></tr>
<tr> <td><syntaxname class="new">dynamic-bindings</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><bnf>&lt;</bnf><typename>DynamicBinding</typename><bnf>&gt;</bnf></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><bnf>&lt;</bnf><typename>DynamicBindings</typename><bnf>&gt;</bnf> & <bnf>&lt;</bnf><typename>DynamicBindings</typename><bnf>&gt;</bnf></inline></td></tr>
<tr> <td><syntaxname class="new">dynamic-binding</syntaxname></td> <td><bnf>→</bnf></td> <td><inline><syntaxname>dyn-var</syntaxname> : <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>dyn-var</syntaxname> : dynamic <syntaxname>expr</syntaxname></inline></td></tr>
<tr> <td></td> <td><bnf>|</bnf></td> <td><inline><syntaxname>dyn-state</syntaxname> : <syntaxname>state</syntaxname></inline></td></tr>
</table>

<p>If a dynamic variable is bound to a <em>dynamic expression</em>, this expression is re-evaluated in the current dynamic environment each time the dynamic variable is accessed.  This way, one dynamic variable can be defined relative another dynamic variable.  For instance:</p>
<pre>
dynamic @smallskip identity 2cm
dynamic @bigskip identity 5cm
test: \ •dst .> { •dst << @bigskip << `¢n´ }
@bigskip : dynamic 4 * @smallskip
|
{
  [test •stdout]
  @smallskip:1cm | [test •stdout]
}
[test •stdout]
</pre>
<p>The program prints <inline>8<lengthunit>cm</lengthunit></inline>, followed by <inline>4<lengthunit>cm</lengthunit></inline>, and finally <inline>5<lengthunit>cm</lengthunit></inline>.</p>

<p>Dynamic variables are used extensively for controlling all parts of the graphics state.  For instance, if <varname>pth</varname> is a path to be stroked, the color and width of the stroke can be set as follows:</p>
<pre>
•page << @stroking:rgb_RED & @width:2cm | [stroke pth]
</pre>
<p>or, if there are several paths to be stroked with the same pen:</p>
<pre>
  @stroking:rgb_RED
& @width:2cm
|
{
  •page << [stroke pth1]
  •page << [stroke pth2]
}
</pre>

<h2>Continuations</h2>
<p>Shapes is currently implemented using full-scale continuations, but their use is restricted by only allowing them to be bound dynamically.  This restriction is enforced using special syntax to handle continuations.  Note that a dynamically bound continuation merely provides the same functionality as an <em>escape continuation</em>.</p>

<p>The reader is referred to the WWW for details on continuations and continuation passing style evaluation.  One place to start would be the documentation for <varname>call-with-current-continuation</varname> found in <a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/doc/r5rs-9.html#Standard-procedures">R5RS</a>.  Here, we only describe the related syntax briefely.</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">with-escape-continuation</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( escape_continuation <syntaxname>identifier</syntaxname> <syntaxname>expr</syntaxname> )</inline></td></tr>
<tr> <td><syntaxname class="new">invoke-escape-continuation</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( escape_continue <syntaxname>identifier</syntaxname> <syntaxname>expr</syntaxname> )</inline></td></tr>
</table>
<p>The construct <syntaxname>with-escape-continuation</syntaxname> introduces an escape continuation in the dynamic environment (although the identifier does not look like a dynamic variable), and evaluates the expression in the new dynamic environment.</p>
<p>To escape through an escsape continuation, the construct <syntaxname>invoke-escape-continuation</syntaxname> is used.  The identifier must refer to an escape continuation in dynamic scope, and evaluation continues by evaluating the new expression with the appropriate continuation.</p>

<p>The keywords <inline>continuation</inline> and <inline>continue</inline> are reserved for future use.</p>

<remark>
<p>Even if continuations are presently handled in a way such that it cannot be determined if they are functions or not, I find it really obscuring to hide a continuation inside a function.  Hence, if continuations are made available more generally in the future, don't expect them to be wrapped in functions.  If a function that behaves like a continuation object in Scheme is needed, such a function will be easy to construct.</p>
</remark>

<h2>Classes and type information</h2>
<p>Since Shapes is dynamically typed, it sometimes becomes important to query and compare types.  Further, it is planned that future versions of the language shall allow for user-defined types.  Read on!</p>

<h2>Other expressiona and expressions in general</h2>
<p>There are many kinds of expressions.  An expression can be either <em>non-pure</em> or <em>pure</em> depending on whether it interacts with states or not.  An expression may also be <em>immediate</em>, wither because it is of a certain kind which is always immediate, or because the user has flagged it to be immediate for some reason.  Expressions that are non-pure or immediate cannot or must not be delayed, and are evaluated in the second phase of code bracket evaluation.  While non-purity is a property that a child can (and generally does) give to its parent in the abstract syntax tree, the immediate flag is never transferred between child and parent.</p>

<h3><a name="laziness">Laziness control</a></h3>
<p>While sequential construction does assure functional binding semantics, even when evaluation is delayed due to laziness, it makes delayed evaluation not completely transparent.  <em>Order of evaluation</em> also becomes important under some circumstances.  Further, prohibiting delayed evaluation may be important for efficiency reasons.  Delayed evaluation is prohibited by flagging an expression as <em>immediate</em>:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">immediate-expr</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>!! <syntaxname>expr</syntaxname></inline></td></tr>
</table>
<p>The double exclamation mark is meant to remind that everything involving states — procedures calls (where there is a single exclamation mark) in particular — are never delayed, and therefore does not need to be flagged immediate.</p>

<h3>Unary operators</h3>

<h3>Binary arithmetic operators</h3>

<h3>Relational operators</h3>


<h1>System bindings</h1>
<p>The language Shapes comes with a set of built-in bindings.  Most of these give access to standard functions, while others give access to type objects.  There are also many important bindings that fall into neither of the previous categories.  The number of system bindings is expected to increase as long as the language is maintained.</p>

<h2>Graphics functions</h2>
<p>After all, Shapes is a special-purpose language aimed at the production of graphics.  Hence, functions for path drawing, creation of affine transforms, and path computations are a very important part of the language.</p>

<p>Remember <varname>immerse</varname> and <varname>facing</varname>, and in particular the <paramname>scale</paramname> and <paramname>distort</paramname> options to <varname>facing</varname>.  The following is quite nice:
</p>
<pre>
facing: [../facing scale:true distort:true ...]
</pre>

<h2>Hot values</h2>
<p>States stem from hot values.  The system provides a few, all of which are important because the efficiency enhancements they bring.</p>

<h2>Type objects</h2>
<p>This section simply contains a listing of the type objects (some of which can be thought of as interfaces) provided by the system.</p>

<h2>LaTeX</h2>
<p>The Shapes language was designed to be used with LaTeX for typesetting labels in the graphics.</p>

<p>The interpreter goes to some lengths to avoid calling LaTeX too many times, but the problems this can cause is more of a tool matter than a language issue.  Here, we shall just describe the laguage constructs that relate to producing labels with LaTeX.</p>

<p>First, there are a few directives that just transfer text to the top of the LaTeX document where the labels are to appear:</p>
<pre>
##documentclass <varname class="replacable">class-name</varname>
##classoption <varname class="replacable">comma-separated-options</varname>
##preamble <varname class="replacable">line-of-text</varname>
##documenttop <varname class="replacable">line-of-text</varname>
##no-lmodernT1
##no-utf8
</pre>
<p>The default document class is <em>article</em>, but this can be changed with the first of these directives.  The following three directives are self-explanatory, and may appear several times.  The last two disable the use of packages that are otherwise included by default.  When they are not disabled, the following goes before the lines from <inline>##preamble</inline>:</p>
<pre>
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
</pre>

<p>To produce the labels themselves, the syntax is simply:</p>
<table cellspacing="5">
<tr> <td><syntaxname class="new">tex-expr</syntaxname></td> <td><bnf>→</bnf></td> <td><inline>( teX <bnf>&lt;</bnf><typename>String</typename><bnf>&gt;</bnf> )</inline></td></tr>
</table>
<p>Note that <varname>teX</varname> is not a function, although it could have been if it was not for efficiency reasons.</p>

<p>If the expression is a string literal, it is handled more efficiently than if the string must be obtained by evaluation.  The origin of the produced label is the same as in LaTeX; at the leftmost point of the baseline.  Unfortunately, fonts lie about their bounding boxes to make them look smaller, and this will cause the produced label to be slightly cropped when imported.  At the moment, I can't think of a good way to get around this problem, since a tight bounding box is important for layout purposes.</p>

<h2>Miscellaneous</h2>
<p>Standard stream objects, null objects, mathematical constants, and more...</p>


<h1>Built-in types</h1>

<h2>Simple types</h2>

<h2>Points and paths</h2>

<h2>Graphics</h2>

<h2>Other</h2>

<h1>Miscellaneous lexer directives</h1>
<p>The following directive allows a source file to print a message to stdout when the file is scanned:</p>
<pre>
##echo <varname class="replacable">text-to-end-of-line-will-be-echoed</varname>
</pre>

<p>You can put your name in the PDF file using the following directive:</p>
<pre>
##author <varname class="replacable">your name</varname>
</pre>
<p>It can be used both in application files and in extension files, although it is not treated as the main author of the produced document in the latter case.</p>

<p>The <varname>srand</varname> function in the Standard C Library, can be accessed through</p>
<pre>
##seed <varname class="replacable">integer</varname>
</pre>
<p>although I don't think there is any reason to do so.  Please consult the documentation on the random number facilities for an explanation.</p>

<h1>Tolerance settings</h1>

</body>
</html>
