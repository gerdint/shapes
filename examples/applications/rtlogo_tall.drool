|***************************************************************************
|** This is a file that is used to generate a particular form of the logo.
|**
|** This form of the logo has bent text above and below, and looks rather
|** different from the other logos.  It can be used in printed material like
|** theses, course material, and books.  (The other logos are used in
|** presentations and posters.)
|***************************************************************************
##author Henrik Tidefelt

##needs rtlogo_elements
##needs circle

##unit t = 9bp
##unit rR = 16mm |** This is the size given to makeRegulator function.

  @stroking:gray_BLACK
& @nonstroking:gray_BLACK
|
{
  /** Recall where this places the regulator...
   **/
  [makeRegulator 1rR •page]
}


|** The bent text is drawn along circular arcs, and we put the text in contact with the regulator's box at
|** the center coordinate.
textRadius: 2rR

smallFont: @text_font:font_HELVETICA_BOLD & @text_size:1t & @text_horizontalscaling:1.0
charHeight: [ymax [bbox smallFont | ( newText << `X´ )]]

{
  /** This is the upper banner.
   ** Since the text is placed on the outside of the circle, no special kerning should be needed.
   **/

  text: smallFont | [kern `REGLERTEKNIK´]
  extraSep: 0.07rR
  textLength: [xmax [bbox (newText << text)]]
  baseline: [shift (0,1rR-(textRadius-1rR)+extraSep)] [] [rotate 90° + 0.5*textLength/textRadius] [] reverse [] [circle textRadius]

|**  •page << @width:0bp & @stroking:rgb_RED | [stroke baseline]
|**  •page << @width:0bp | [stroke (~1rR,[baseline 0].p.y)--(1rR,(+0r))]
  
  /** At the time of writing, there is no abstraction for placing text along a path, but this is the
   ** standard way of doing it.
   **/
  •page <<
   [text.list.foldl
      \ pile distChar .>
       {
         c: ( newText << distChar.cdr )
         sl: [baseline distChar.car + 0.5*[xmax [bbox c]]]
         pile
         &
         [[shift sl.p]()[rotate [angle sl.t]] [centerx c] ]
       }
      null]
}

{
  /** This is the lower banner.
   ** Since the text is placed on the inside of the circle, some negative kerning must be used.
   **/
  
  stdkern: charHeight/textRadius
  text: smallFont | ( @text_characterspacing:stdkern*@text_size | [kerning [kern `AUTOM´] 0.08 `A´ 0.13 [kern `TIC CONTROL´]] )
  textLength: [xmax [bbox (newText << text)]]
  baseline: [shift (0,1rR-1.2*charHeight+(textRadius-1rR))] [] [rotate ~90° - 0.5*textLength/textRadius] [] [circle textRadius]

|**  •page << @width:0bp & @stroking:rgb_RED | [stroke baseline]
  
  /** At the time of writing, there is no abstraction for placing text along a path, but this is the
   ** standard way of doing it.
   **/
  •page <<
   [text.list.foldl
      \ pile distChar .>
       {
         c: ( newText << distChar.cdr )
         sl: [baseline distChar.car + 0.5*[xmax [bbox c]]]
         pile
         &
         [[shift sl.p]()[rotate [angle sl.t]] [centerx c] ]
       }
      null]
}

•page <<
smallFont | 
[shift (0,~0.65rR)][]
{
  hbar: @width:0.05t| [stroke (~1rR,0)--(1rR,0)]  |** The width used to be 0.02r.
  ( newGroup2D
    << [shift (0,~0.3*@text_size)] [] hbar
    << [shift (0,1.11*@text_size)] [] hbar
    << [centerx ( newText << [kerning [kern `LINK´] kernKO [kern `ÖPING´]] )] )
}
