##needs conssupport
##needs blockdraw_wfo

/**
N := 1000:
R := [evalf(seq(2/N*(N-i),i=1..N))]:
phi := [evalf(seq(1.4*Pi/N*(N-i)+0.5,i=1..N))]:
p3 := plot3d(sin(x*y),x=-2.1..2.1,y=-2.1..2.1,grid=[15,15],style=patch,color=white): # 2.1  [15,15] el. [25,25] för hög eller

points:= [seq([R[i]*sin(phi[i]),R[i]*cos(phi[i]),sin(R[i]*sin(phi[i])*R[i]*cos(phi[i]))],i=1..N)]:
p4 := pointplot3d(points,style=LINE,thickness=2,color=black):
p5 := pointplot3d(points[-1],color=black,symbol=solidsphere,symbolsize=20):
p6 := pointplot3d(points[1],color=black,symbol=solidsphere,symbolsize=20):

display(p3,p4,p5,orientation=[-17,25]);
**/

R: 5cm
u: R/2.1

/** The function describing the manifold.
 **/
surfz: \ p .> (0.24*R) * [sin (p.x/u) * (p.y/u)]

/** A general-purpose helper.
 **/
surfit: \ f p .> ( p.x, p.y, [f p] )

/** A general-purpose surface-circle.
 **/
surfaceCircle: \ f r c sides:'12 .>
{
  mid: [surfit f c]
	[[range '0 sides-'1].foldl
   \ p e .> p & [fill mid--[surfit f c+r*[dir (360°*e)/sides]]--[surfit f c+r*[dir (360°*(e+'1))/sides]]--cycle]
	 null3D]
}

/** A path on our surface.
 **/
points:
{
  N: '100
	[[range '1 N].foldl
	 \ p i .>
	 	 p--[surfit surfz (2/N)*(N-i)*u*[dir 90°-(1.4*(180°/N)*(N-i)-0)]]
   emptypath3D]
}


foldpairsl:
{
  helper: \ op nullRes last lst .> [if [null? lst] nullRes [helper op [op nullRes last lst.car] lst.car lst.cdr]]

  \ op nullRes lst .>
    [if [null? lst]
			lst
		 	[helper op nullRes lst.car lst.cdr]]
}

foldtriplesl:
{
  helper: \ op nullRes back2 back1 lst .> [if [null? lst] nullRes [helper op [op nullRes back2 back1 lst.car] back1 lst.car lst.cdr]]

  \ op nullRes lst .>
    [if [null? lst]
			lst
      [if [null? lst.cdr]
	  		[list]
		   	[helper op nullRes lst.car lst.cdr.car lst.cdr.cdr]]]
}

functionMesh: \ zMap xRange yRange step:'1 .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
  [foldl
    \ p x .>
			p
			&
			[stroke
        [yRange.foldl
           \ p y .> p--[xyz (x,y)]
           emptypath3D
			]]
    null3D
		[sublist [consify xRange] step]
  ]
	&
  [foldl
    \ p y .>
			p
			&
			[stroke
        [xRange.foldl
           \ p x .> p--[xyz (x,y)]
           emptypath3D
			]]
    null3D
		[sublist [consify yRange] step]
  ]
}

functionSurface: \ zMap xRange yRange .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
	xConsRange: [consify xRange]
	yConsRange: [consify yRange]
  [foldpairsl
    \ p x1 x2 .>
			p
			&
      [foldpairsl
         \ p y1 y2 .>
          p
					&
					{
					  p11: [xyz (x1,y1)]
					  p12: [xyz (x1,y2)]
					  p21: [xyz (x2,y1)]
					  p22: [xyz (x2,y2)]
					  pc: [xyz (0.5*(x1+x2),0.5*(y1+y2))]
						[fill pc--p11--p12--cycle]
						&
						[fill pc--p12--p22--cycle]
						&
						[fill pc--p22--p21--cycle]
						&
						[fill pc--p21--p11--cycle]
/**
						&
						[stroke p11--pc--p22]
						&
						[stroke p12--pc--p21]
**/
					}
         null3D
				yConsRange
			]
    null3D
		xConsRange
  ]
/**
	&
	[functionMesh zMap xRange yRange]
**/
}

angle_in_ccw_range?: \ a low high .>
{
	am: [mod a - low 360°]
	[if am < 0 am+360° am] < high - low
}

ridgeLines: \ zMap xRange yRange tf .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
  ccwConcaveCorner: \ p1 p2 p3 .> [if [orthogonal [normalized p3-p2]]*([normalized p3-p2]+[normalized p1-p2]) < 0
									 	 			 			 		 '1
																		 '0]
	test: \ neighbor1 corner neighbor2 opposite center .>
	  {
		  a1: [angle [normalized neighbor1 - corner]]
		  a2tmp: [angle [normalized neighbor2 - corner]]
			a2: [if a2tmp > a1 a2tmp-360° a2tmp]
			ac: [mod [angle center - corner] - a2
			         360°]
			[if ac < 0 ac+360° ac] > a1 - a2
    }
	xConsRange: [consify xRange]
	yConsRange: [consify yRange]
  [foldpairsl
    \ p x1 x2 .>
      [foldpairsl
        \ p y1 y2 .>
					{
					  p11: view [] tf [] [xyz (x1,y1)]
					  p12: view [] tf [] [xyz (x1,y2)]
					  p21: view [] tf [] [xyz (x2,y1)]
					  p22: view [] tf [] [xyz (x2,y2)]

					  pc:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y1+y2))]
						pc3D: [xyz (0.5*(x1+x2),0.5*(y1+y2))]

		  			ccw:   [ccwConcaveCorner p11 p12 p22]
					 			 + [ccwConcaveCorner p12 p22 p21]
					 			 + [ccwConcaveCorner p22 p21 p11]
					 			 + [ccwConcaveCorner p21 p11 p12]
					 			 <= '1

						p
						&
						[if ccw
						  (
  						  [if [test p21 p11 p12 p22 pc] [stroke [xyz (x1,y1)]--pc3D] null3D]
						    &
						    [if [test p11 p12 p22 p21 pc] [stroke [xyz (x1,y2)]--pc3D] null3D]
						    &
						    [if [test p12 p22 p21 p11 pc] [stroke [xyz (x2,y2)]--pc3D] null3D]
						    &
						    [if [test p22 p21 p11 p12 pc] [stroke [xyz (x2,y1)]--pc3D] null3D]
						 )
						  (
  						  [if [test p12 p11 p21 p22 pc] [stroke [xyz (x1,y1)]--pc3D] null3D]
						    &
						    [if [test p22 p12 p11 p21 pc] [stroke [xyz (x1,y2)]--pc3D] null3D]
						    &
						    [if [test p21 p22 p12 p11 pc] [stroke [xyz (x2,y2)]--pc3D] null3D]
						    &
						    [if [test p11 p21 p22 p12 pc] [stroke [xyz (x2,y1)]--pc3D] null3D]
						 )
					 ]
					}
        p
				yConsRange
			]
    null3D
		xConsRange
  ]
	&
  [foldtriplesl
    \ p x1 x2 x3 .>
      [foldpairsl
        \ p y1 y2 .>
					{
					  p1: view [] tf [] [xyz (x2,y1)]
					  p2: view [] tf [] [xyz (x2,y2)]
					  pc1:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y1+y2))]
					  pc2:  view [] tf [] [xyz (0.5*(x2+x3),0.5*(y1+y2))]
						d11: [normalized pc1 - p1]
						d12: [normalized pc2 - p1]
						dm1: d11 + d12
						d21: [normalized pc1 - p2]
						d22: [normalized pc2 - p2]
						dm2: d21 + d22
						dc: [normalized p2 - p1]
						[if ( dm1*dc > dm1*d11 ) or ( ~(dm2*dc) > dm2*d22 )
						  p
							p & [stroke [xyz (x2,y1)]--[xyz (x2,y2)]]]
					}
        p
				yConsRange
			]
    null3D
		xConsRange
  ]
	&
  [foldtriplesl
    \ p y1 y2 y3 .>
      [foldpairsl
        \ p x1 x2 .>
					{
					  p1: view [] tf [] [xyz (x1,y2)]
					  p2: view [] tf [] [xyz (x2,y2)]
					  pc1:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y1+y2))]
					  pc2:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y2+y3))]
						d11: [normalized pc1 - p1]
						d12: [normalized pc2 - p1]
						dm1: 0.5 * ( d11 + d12 )
						d21: [normalized pc1 - p2]
						d22: [normalized pc2 - p2]
						dm2: 0.5 * ( d21 + d22 )
						dc: [normalized p2 - p1]
						[if ( dm1*dc > dm1*d11 ) or ( ~(dm2*dc) > dm2*d22 )
						  p
							p & [stroke [xyz (x1,y2)]--[xyz (x2,y2)]]]
					}
        p
				xConsRange
			]
    null3D
		yConsRange
  ]
}

T_view: [rotate3D dir:(1,0,0) angle:~90°-~19°]*[rotate3D dir:(0,0,1) angle:~90°+25°]

N_major: '15
N_minor: '3
xRange: [range ~R R count: N_major * N_minor + '1]
yRange: [range ~R R count: N_major * N_minor + '1]

•page << [view
				   T_view
					 []
					 ( newZSorter
					   <<   @nonstroking:OCCLUDING
						    & @width: 0.3bp
					 	 		| [functionSurface surfz xRange yRange]
					   << @width: 0.3bp
					 	 		| [functionMesh surfz xRange yRange N_minor]
					   << @width: 0.3bp
					 	 		| [ridgeLines surfz xRange yRange T_view]
					 )
				 ]
•page << [view
				   T_view
					 []
					 ( newGroup3D
					 	 << @width:1.5bp & @cap:CAP_ROUND | [stroke points]
						 << [surfaceCircle surfz 4bp (points.begin.p.x,points.begin.p.y)]
						 << [surfaceCircle surfz 4bp (points.end.p.x,points.end.p.y)]
					 )
				 ]


/**
 ** Add coordinate arrows to ease development!
 **/

/**
pointMark: [facing [fill [circle 2bp]]]

baseVectors3D: \ nx ny nz .>
{
	len: 1*u
	tmpHead: [MetaPostArrow3D ahLength:3mm ...]
	@width: 1.5bp
	|
  ( newGroup3D
	  << pointMark
	  << [stroke (0m,0m,0m)--(len,0m,0m) head:[tmpHead normal:nx ...]]
	  << [stroke (0m,0m,0m)--(0m,len,0m) head:[tmpHead normal:ny ...]]
	  << [stroke (0m,0m,0m)--(0m,0m,len) head:[tmpHead normal:nz ...]]
		<< [tag 'x (len,0m,0m)]
		<< [tag 'y (0m,len,0m)]
		<< [tag 'z (0m,0m,len)]
  )
}

•page << [view
				   (T_view*[shift (0m,0m,~R)])
					 []
{
	base: [baseVectors3D (0,0,1) (0,0,1) (1,0,0)]
  ( newGroup3D
	  << base
	  << [shift [find base 'x]] [] [facing [putlabelBelow (TeX `$x$´) (0m,0m) ~1]]
	  << [shift [find base 'y]] [] [facing [putlabelRight (TeX `$y$´) (0m,0m) ~1]]
	  << [shift [find base 'z]] [] [facing [putlabelAbove (TeX `$z$´) (0m,0m) 1]]
  )
}
]
**/
