<section id="state-types/containers">
<title>Containers</title>
<top>
	<p>States of types in this section are used to produce containers with objects in.</p>
</top>

  <core-state-type name="Group">
    <abstraction>
      <p>States of type <self /> are used to fill containers of type <named-type name="Group" />.</p>
    </abstraction>
    <construction>
			<binding name="newGroup" />
    </construction>
		<mutator op="tack-on">
			<function>
				<case>
					<arguments>
						<arg>
							<type><named-type name="Drawable" /></type>
						</arg>
					</arguments>
					<dynamic-references><dynvar name="blend" /></dynamic-references>
					<side-effect>
						<p>Put element on top of pile.</p>
					</side-effect>
				</case>
			</function>
		</mutator>
		<mutator op="peek">
			<function>
				<case>
					<result>
						<type><named-type name="Group" /></type>
					</result>
					<dynamic-references></dynamic-references>
					<description>
						<p>Get current pile.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator op="freeze">
			<function>
				<case>
					<result>
						<type><named-type name="Group" /></type>
					</result>
					<dynamic-references></dynamic-references>
					<description>
						<p>Get current pile.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator identifier="erase">
			<function>
				<case>
					<arguments>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Erase contents.</p>
					</side-effect>
					<description>
						<p>A common application of this is when <state name="page" /> has been used to define the contents of the pages in <state name="catalog" />.  Then, when <state name="catalog" /> is non-empty at the end of the program, it is an error if <state name="page" /> is also non-tmpty.  All you have to do then is to write
<pre>
•page.[erase]
</pre>
at the end of the program.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator identifier="remove">
			<function>
				<case>
					<arguments>
						<arg identifier="key">
							<type><named-type name="Symbol" /></type>
						</arg>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Remove <em>shallow</em> tagged objects with the key <arg name="key" />.</p>
					</side-effect>
					<description>
						<p>Here, <em>shallow</em> refers to objects that were tacked on directly to the state.  For instance,
<pre>
•page &lt;&lt; [shift (1cm,0cm)] [] [tag 'a [stroke (0cm,0cm)--(1cm,1cm)]]
•page.[remove 'a]
</pre>
will <em>not</em> remove the stroke from the page, since the value being tacked on to the state is transformed.  To make it work, apply the transform to the object being tagged:
<pre>
•page &lt;&lt; [tag 'a  [[shift (1cm,0cm)] [stroke (0cm,0cm)--(1cm,1cm)]]]
</pre>
</p>
					</description>
					<see-also>
						<binding name="tag" />
					</see-also>
				</case>
			</function>
		</mutator>
  </core-state-type>

  <core-state-type name="Group3D">
    <abstraction>
      <p>States of type <self /> are used to fill containers of type <named-type name="Group3D" />.</p>
    </abstraction>
    <construction>
			<binding name="newGroup3D" />
    </construction>
		<mutator identifier="erase">
			<function>
				<case>
					<arguments>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Erase contents.</p>
					</side-effect>
					<description>
						<p>Analogous to <mutator type="Group" mutator="erase" />.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator identifier="remove">
			<function>
				<case>
					<arguments>
						<arg identifier="key">
							<type><named-type name="Symbol" /></type>
						</arg>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Remove <em>shallow</em> tagged objects with the key <arg name="key" />.</p>
					</side-effect>
					<description>
						<p>Analogous to <mutator type="Group" mutator="remove" />.</p>
					</description>
				</case>
			</function>
		</mutator>
  </core-state-type>

  <core-state-type name="Catalog">
    <abstraction>
      <p>States of type <self /> are used to construct documents with many pages, page labels, cross references, and so on.</p>
    </abstraction>
    <construction>
			<state name="catalog" />
    </construction>
  </core-state-type>


  <core-state-type name="Text">
    <abstraction>
      <p>States of type <self /> are used to combine font properties with strings to paint text.</p>
    </abstraction>
    <construction>
			<state name="newText" />
    </construction>
		<tack-on>
			<case>
				<types><named-type name="String" /></types>
				<dynamic-references><dynvar name="blend" /></dynamic-references>
				<dynamic-references>
					<dynvar name="text_font" />
					<dynvar name="text_characterspacing" />
					<dynvar name="text_wordspacing" />
					<dynvar name="text_horizontalscaling" />
					<dynvar name="text_leading" />
					<dynvar name="text_font" />
					<dynvar name="text_size" />
					<dynvar name="text_rendering" />
					<dynvar name="text_rise" />
					<dynvar name="text_knockout" />
				</dynamic-references>
			</case>
		</tack-on>
		<freeze>
			<type><named-type name="Drawable" /></type>
		</freeze>
  </core-state-type>

</section>
