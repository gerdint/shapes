##needs conssupport
/**
N := 1000:
R := [evalf(seq(2/N*(N-i),i=1..N))]:
phi := [evalf(seq(1.4*Pi/N*(N-i)+0.5,i=1..N))]:
p3 := plot3d(sin(x*y),x=-2.1..2.1,y=-2.1..2.1,grid=[15,15],style=patch,color=white): # 2.1  [15,15] el. [25,25] för hög eller

points:= [seq([R[i]*sin(phi[i]),R[i]*cos(phi[i]),sin(R[i]*sin(phi[i])*R[i]*cos(phi[i]))],i=1..N)]:
p4 := pointplot3d(points,style=LINE,thickness=2,color=black):
p5 := pointplot3d(points[-1],color=black,symbol=solidsphere,symbolsize=20):
p6 := pointplot3d(points[1],color=black,symbol=solidsphere,symbolsize=20):

display(p3,p4,p5,orientation=[-17,25]);
**/

R: 5cm
u: R/2.1

/** The function describing the manifold.
 **/
surfz: \ p .> (0.24*R) * [sin (p.x/u) * (p.y/u)]

/** A general-purpose helper.
 **/
surfit: \ f p .> ( p.x, p.y, [f p] )

/** A general-purpose surface-circle.
 **/
surfaceCircle: \ f r c sides:'12 .>
{
  mid: [surfit f c]
	[[range '0 sides-'1].foldl
   \ p e .> p & [fill mid--[surfit f c+r*[dir (360°*e)/sides]]--[surfit f c+r*[dir (360°*(e+'1))/sides]]--cycle]
	 null3D]
}

/** A path on our surface.
 **/
points:
{
  N: '100
	[[range '1 N].foldl
	 \ p i .>
	 	 p--[surfit surfz (2/N)*(N-i)*u*[dir 90°-(1.4*(180°/N)*(N-i)-0)]]
   emptypath3D]
}


foldpairsl:
{
  helper: \ op nullRes last lst .> [if [null? lst] nullRes [helper op [op nullRes last lst.car] lst.car lst.cdr]]

  \ op nullRes lst .>
    [if [null? lst]
			lst
		 	[helper op nullRes lst.car lst.cdr]]
}

foldtriplesl:
{
  helper: \ op nullRes back2 back1 lst .> [if [null? lst] nullRes [helper op [op nullRes back2 back1 lst.car] back1 lst.car lst.cdr]]

  \ op nullRes lst .>
    [if [null? lst]
			lst
      [if [null? lst.cdr]
	  		[list]
		   	[helper op nullRes lst.car lst.cdr.car lst.cdr.cdr]]]
}

functionMesh: \ zMap xRange yRange step:'1 .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
  [foldl
    \ p x .>
			p
			&
			[stroke
        [yRange.foldl
           \ p y .> p--[xyz (x,y)]
           emptypath3D
			]]
    null3D
		[sublist [consify xRange] step]
  ]
	&
  [foldl
    \ p y .>
			p
			&
			[stroke
        [xRange.foldl
           \ p x .> p--[xyz (x,y)]
           emptypath3D
			]]
    null3D
		[sublist [consify yRange] step]
  ]
}

functionSurface: \ zMap xRange yRange .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
	xConsRange: [consify xRange]
	yConsRange: [consify yRange]
  [foldpairsl
    \ p x1 x2 .>
			p
			&
      [foldpairsl
         \ p y1 y2 .>
          p
					&
					{
					  p11: [xyz (x1,y1)]
					  p12: [xyz (x1,y2)]
					  p21: [xyz (x2,y1)]
					  p22: [xyz (x2,y2)]
					  pc: [xyz (0.5*(x1+x2),0.5*(y1+y2))]
						[fill pc--p11--p12--cycle]
						&
						[fill pc--p12--p22--cycle]
						&
						[fill pc--p22--p21--cycle]
						&
						[fill pc--p21--p11--cycle]
/**
						&
						[stroke p11--pc--p22]
						&
						[stroke p12--pc--p21]
**/
					}
         null3D
				yConsRange
			]
    null3D
		xConsRange
  ]
/**
	&
	[functionMesh zMap xRange yRange]
**/
}

angle_in_ccw_range?: \ a low high .>
{
	am: [mod a - low 360°]
	[if am < 0 am+360° am] < high - low
}

ridgeLines:
{
  ridgeTest: \ p1 p2 o1 o2 .>
  {
    d11: [normalized o1 - p1]
    d12: [normalized o2 - p1]
    dm1: d11 + d12
    d21: [normalized o1 - p2]
    d22: [normalized o2 - p2]
    dm2: d21 + d22
    dc: [normalized p2 - p1]
    ( dm1*dc <= dm1*d11 ) and ( ~(dm2*dc) <= dm2*d22 )
  }

 \ zMap xRange yRange tf .>
  {
    xyz: \ p .> ( p.x, p.y, [zMap p] )

  	xConsRange: [consify xRange]
  	yConsRange: [consify yRange]
    [foldpairsl
      \ p x1 x2 .>
        [foldpairsl
          \ p y1 y2 .>
  					{
  					  p11: view [] tf [] [xyz (x1,y1)]
  					  p12: view [] tf [] [xyz (x1,y2)]
  					  p21: view [] tf [] [xyz (x2,y1)]
  					  p22: view [] tf [] [xyz (x2,y2)]

  					  pc:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y1+y2))]
  						pc3D: [xyz (0.5*(x1+x2),0.5*(y1+y2))]

  						p
  						&
    						  [if [ridgeTest p11 pc p12 p21] [stroke [xyz (x1,y1)]--pc3D] null3D]
  						    &
  						    [if [ridgeTest p12 pc p11 p22] [stroke [xyz (x1,y2)]--pc3D] null3D]
  						    &
  						    [if [ridgeTest p22 pc p12 p21] [stroke [xyz (x2,y2)]--pc3D] null3D]
  						    &
  						    [if [ridgeTest p21 pc p11 p22] [stroke [xyz (x2,y1)]--pc3D] null3D]
  					}
          p
  				yConsRange
  			]
      null3D
  		xConsRange
    ]
  	&
    [foldtriplesl
      \ p x1 x2 x3 .>
        [foldpairsl
          \ p y1 y2 .>
  					{
  					  p1: view [] tf [] [xyz (x2,y1)]
  					  p2: view [] tf [] [xyz (x2,y2)]
  					  pc1:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y1+y2))]
  					  pc2:  view [] tf [] [xyz (0.5*(x2+x3),0.5*(y1+y2))]
  						[if [ridgeTest p1 p2 pc1 pc2]
  							p & [stroke [xyz (x2,y1)]--[xyz (x2,y2)]]
  							p]
  					}
          p
  				yConsRange
  			]
      null3D
  		xConsRange
    ]
  	&
    [foldtriplesl
      \ p y1 y2 y3 .>
        [foldpairsl
          \ p x1 x2 .>
  					{
  					  p1: view [] tf [] [xyz (x1,y2)]
  					  p2: view [] tf [] [xyz (x2,y2)]
  					  pc1:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y1+y2))]
  					  pc2:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y2+y3))]
  						[if [ridgeTest p1 p2 pc1 pc2]
  							p & [stroke [xyz (x1,y2)]--[xyz (x2,y2)]]
  							p]
  					}
          p
  				xConsRange
  			]
      null3D
  		yConsRange
    ]
  }
}

T_view: [rotate3D dir:(1,0,0) angle:~90°-~19°]*[rotate3D dir:(0,0,1) angle:~90°+25°]

N_major: '12
N_minor: '4
xRange: [range ~R R count: N_major * N_minor + '1]
yRange: [range ~R R count: N_major * N_minor + '1]

•page << @width:0.8bp
			   |
				 [view
				   T_view
					 []
					 ( newZSorter
					   <<   @nonstroking:OCCLUDING
					 	 		| [functionSurface surfz xRange yRange]
					   << [functionMesh surfz xRange yRange N_minor]
					   << [ridgeLines surfz xRange yRange T_view]
					 )
				 ]
•page << @width:2.5bp
			   |
				 [view
				   T_view
					 []
					 ( newGroup3D
					 	 << @cap:CAP_ROUND | [stroke points]
						 << [surfaceCircle surfz 2.5*@width (points.begin.p.x,points.begin.p.y)]
						 << [surfaceCircle surfz 2.5*@width (points.end.p.x,points.end.p.y)]
					 )
				 ]
