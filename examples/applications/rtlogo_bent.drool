|***************************************************************************
|** This is a file that is used to generate a particular form of the logo.
|**
|** This form of the logo has bent text above and below, and looks rather
|** different from the other logos.  It can be used in printed material like
|** theses, course material, and books.  (The other logos are used in
|** presentations and posters.)
|***************************************************************************
##author Henrik Tidefelt

##needs rtlogo_elements
##needs circle

•page << [bboxed null [rectangle (~1r,0cm) (1r,2r)]]

  @stroking:gray_BLACK
& @nonstroking:gray_BLACK
|
{
  /** Recall where this places the regulator...
   **/
  [makeRegulator •page]
}


|** The bent text is drawn along circular arcs, and we put the text in contact with the regulator's box at
|** the center coordinate.
textRadius: 2r

smallFont: @text_font:font_HELVETICA & @text_size:0.2r & @text_horizontalscaling:0.8
largeFont: @text_font:font_HELVETICA & @text_size:0.15r*golden & @text_horizontalscaling:0.8

{
  |** This is the upper banner.

  text: smallFont | [kern `REGLERTEKNIK´]
  baseline: [shift (0,1r-(textRadius-1r))] [] [rotate 90° + 0.5*[xmax [bbox ( newText << text )]]/textRadius] [] reverse [] [circle textRadius]

##needs arrowheads

  /** At the time of writing, there is no abstraction for placing text along a path, but this is the
   ** standard way of doing it.
   **/
  •page <<
   [text.list.foldl
      \ pile distChar .>
       {
         c: ( newText << distChar.cdr )
         sl: [baseline distChar.car + 0.5*[xmax [bbox c]]]
         pile
         &
         [[shift sl.p]()[rotate [angle sl.t]] [centerx c] ]
       }
      null]
}

{
  |** This is the lower banner.

  text: smallFont | [kern `AUTOMATIC CONTROL´]
  baseline: [shift (0,1r-(smallFont|@text_size)+(textRadius-1r))] [] [rotate ~90° - 0.5*[xmax [bbox (newText << text)]]/textRadius] [] [circle textRadius]

  /** At the time of writing, there is no abstraction for placing text along a path, but this is the
   ** standard way of doing it.
   **/
  •page <<
   [text.list.foldl
      \ pile distChar .>
       {
         c: ( newText << distChar.cdr )
         sl: [baseline distChar.car + 0.5*[xmax [bbox c]]]
         pile
         &
         [[shift sl.p]()[rotate [angle sl.t]] [centerx c] ]
       }
      null]
}

