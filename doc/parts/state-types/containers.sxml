<section id="state-types/containers">
<title>Containers</title>
<top>
	<p>States of types in this section are used to produce containers with objects in.</p>
</top>

  <core-state-type name="Group">
    <abstraction>
      <p>States of type <self /> are used to fill containers of type <named-type name="Group" />.</p>
    </abstraction>
    <construction>
			<binding name="newGroup" />
    </construction>
		<mutator op="tack-on">
			<function>
				<case>
					<arguments>
						<arg>
							<type><named-type name="Drawable" /></type>
						</arg>
					</arguments>
					<dynamic-references><dynvar name="blend" /></dynamic-references>
					<side-effect>
						<p>Put element on top of pile.</p>
					</side-effect>
				</case>
			</function>
		</mutator>
		<mutator op="peek">
			<function>
				<case>
					<result>
						<type><named-type name="Group" /></type>
					</result>
					<dynamic-references></dynamic-references>
					<description>
						<p>Get current pile.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator op="freeze">
			<function>
				<case>
					<result>
						<type><named-type name="Group" /></type>
					</result>
					<dynamic-references></dynamic-references>
					<description>
						<p>Get current pile.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator identifier="erase">
			<function>
				<case>
					<arguments>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Erase contents.</p>
					</side-effect>
					<description>
						<p>A common application of this is when <state name="page" /> has been used to define the contents of the pages in <state name="catalog" />.  Then, when <state name="catalog" /> is non-empty at the end of the program, it is an error if <state name="page" /> is also non-tmpty.  All you have to do then is to write
<pre>
•page.[erase]
</pre>
at the end of the program.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator identifier="remove">
			<function>
				<case>
					<arguments>
						<arg identifier="key">
							<type><named-type name="Symbol" /></type>
						</arg>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Remove <em>shallow</em> tagged objects with the key <arg name="key" />.</p>
					</side-effect>
					<description>
						<p>Here, <em>shallow</em> refers to objects that were tacked on directly to the state.  For instance,
<pre>
•page &lt;&lt; [shift (1cm,0cm)] [] [tag 'a [stroke (0cm,0cm)--(1cm,1cm)]]
•page.[remove 'a]
</pre>
will <em>not</em> remove the stroke from the page, since the value being tacked on to the state is transformed.  To make it work, apply the transform to the object being tagged:
<pre>
•page &lt;&lt; [tag 'a  [[shift (1cm,0cm)] [stroke (0cm,0cm)--(1cm,1cm)]]]
</pre>
</p>
					</description>
					<see-also>
						<binding name="tag" />
					</see-also>
				</case>
			</function>
		</mutator>
  </core-state-type>

  <core-state-type name="Group3D">
    <abstraction>
      <p>States of type <self /> are used to fill containers of type <named-type name="Group3D" />.</p>
    </abstraction>
    <construction>
			<binding name="newGroup3D" />
    </construction>
		<mutator op="tack-on">
			<function>
				<case>
					<arguments>
						<arg>
							<type><named-type name="Drawable3D" /></type>
						</arg>
					</arguments>
					<dynamic-references><dynvar name="blend" /></dynamic-references>
					<side-effect>
						<p>Put element on top of pile.</p>
					</side-effect>
				</case>
			</function>
		</mutator>
		<mutator op="peek">
			<function>
				<case>
					<result>
						<type><named-type name="Group3D" /></type>
					</result>
					<dynamic-references></dynamic-references>
					<description>
						<p>Get current pile.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator op="freeze">
			<function>
				<case>
					<result>
						<type><named-type name="Group3D" /></type>
					</result>
					<dynamic-references></dynamic-references>
					<description>
						<p>Get current pile.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator identifier="erase">
			<function>
				<case>
					<arguments>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Erase contents.</p>
					</side-effect>
					<description>
						<p>Analogous to <mutator type="Group" mutator="erase" />.</p>
					</description>
				</case>
			</function>
		</mutator>
		<mutator identifier="remove">
			<function>
				<case>
					<arguments>
						<arg identifier="key">
							<type><named-type name="Symbol" /></type>
						</arg>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Remove <em>shallow</em> tagged objects with the key <arg name="key" />.</p>
					</side-effect>
					<description>
						<p>Analogous to <mutator type="Group" mutator="remove" />.</p>
					</description>
				</case>
			</function>
		</mutator>
  </core-state-type>

  <core-state-type name="Catalog">
    <abstraction>
      <p>States of type <self /> are used to construct documents with many pages, page labels, cross references, and so on.</p>
    </abstraction>
    <construction>
			<state name="catalog" />
    </construction>
		<description>
			<p>There is currently no way a user can create their own <named-state-type name="Catalog" /> states; only the global <state name="catalog" /> may be accessed.  It is directly associated with the program output, so instead of peeking or freezing the state, the program is terminated, at which point the contents of the state is used.</p>
		</description>
		<see-also>
			<state name="catalog" />
		</see-also>
		<mutator op="tack-on">
			<function>
				<case>
					<arguments>
						<arg>
							<type><named-type name="Drawable" /></type>
						</arg>
					</arguments>
					<dynamic-references><dynvar name="eyez" /></dynamic-references>
					<side-effect>
						<p>Add graphics as page att the end of the catalog.</p>
						<p>Note that a <named-type name="Drawable" /> value can contain objects that have special meaning when appearing on a page out output.  Below, functions that construct such objects are listed.</p>
						<p>Don't expect the lista of dynamic references to be complete, and don't expect any of the listed references to actually be used.</p>
					</side-effect>
					<see-also>
						<binding name="destination" />
						<binding name="site" />
						<binding name="annotationText" />
						<binding name="annotationLaunch" />
						<binding name="annotationLink" />
					</see-also>
				</case>
			</function>
		</mutator>
  </core-state-type>


  <core-state-type name="Text">
    <abstraction>
      <p>States of type <self /> are used to combine font properties with strings to paint text.</p>
    </abstraction>
    <construction>
			<state name="newText" />
    </construction>
		<mutator op="tack-on">
			<function>
				<case>
					<arguments>
						<arg>
							<type><named-type name="TextOperation" /></type>
						</arg>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Append operation.</p>
					</side-effect>
				</case>
				<case>
					<arguments>
						<arg>
							<type><named-type name="String" /></type>
						</arg>
					</arguments>
					<dynamic-references>
						<dynvar name="text_font" />
						<dynvar name="text_characterspacing" />
						<dynvar name="text_wordspacing" />
						<dynvar name="text_horizontalscaling" />
						<dynvar name="text_leading" />
						<dynvar name="text_font" />
						<dynvar name="text_size" />
						<dynvar name="text_rendering" />
						<dynvar name="text_rise" />
						<dynvar name="text_knockout" />
					</dynamic-references>
					<side-effect>
						<p>Append text without kerning.</p>
					</side-effect>
				</case>
				<case>
					<arguments>
						<arg>
							<type><named-type name="Transform" /></type>
						</arg>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Append <em>move to</em> command.</p>
					</side-effect>
				</case>
				<case>
					<arguments>
						<arg>
							<type><named-type name="Coords" /></type>
						</arg>
					</arguments>
					<dynamic-references></dynamic-references>
					<side-effect>
						<p>Append <em>newline</em> command followed by relative move.</p>
					</side-effect>
				</case>
				<case>
					<arguments>
						<arg>
							<type><named-type name="FloatPair" /></type>
						</arg>
					</arguments>
					<dynamic-references>
						<dynvar name="text_size" />
					</dynamic-references>
					<side-effect>
						<p>Append <em>newline</em> command followed by relative move, interpreting the move in units of <dynvar name="text_size" />.</p>
					</side-effect>
				</case>
			</function>
		</mutator>
		<mutator op="freeze">
			<function>
				<case>
					<result>
						<type><named-type name="Drawable" /></type>
					</result>
					<dynamic-references><dynstate name="graphics" /> <dynstate name="text" /></dynamic-references>
					<description>
						<p>Produce graphic representation of entered objects.</p>
					</description>
				</case>
			</function>
		</mutator>
		<freeze>
			<type><named-type name="Drawable" /></type>
		</freeze>
  </core-state-type>

</section>
