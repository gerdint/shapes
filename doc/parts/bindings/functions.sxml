<!-- This file is part of Shapes.                                           -->
<!--                                                                        -->
<!-- Shapes is free software: you can redistribute it and/or modify         -->
<!-- it under the terms of the GNU General Public License as published by   -->
<!-- the Free Software Foundation, either version 3 of the License, or      -->
<!-- any later version.                                                     -->
<!--                                                                        -->
<!-- Shapes is distributed in the hope that it will be useful,              -->
<!-- but WITHOUT ANY WARRANTY; without even the implied warranty of         -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          -->
<!-- GNU General Public License for more details.                           -->
<!--                                                                        -->
<!-- You should have received a copy of the GNU General Public License      -->
<!-- along with Shapes.  If not, see <http://www.gnu.org/licenses/>.        -->
<!--                                                                        -->
<!-- Copyright 2008 Henrik Tidefelt                                         -->

<section id="bindings/functions">
<title>Functions</title>
<top>
<p>These are the functions!</p>

<p>After all, <str-Shapes /> is a special-purpose language aimed at the production of graphics.  Hence, functions for path drawing, creation of affine transforms, and path computations are a very important part of the language.</p>

<p>Remember <binding name="immerse" /> and <binding name="facing" />, and in particular the <arg name="scale" /> and <arg name="distort" /> options to <binding name="facing" />.  The following is quite nice:
</p>
<pre>
facing: [../facing scale:true distort:true ...]
</pre>
</top>

<system-binding identifier="affinetransform">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg>
					<type><named-type name="FloatPair" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatPair" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform from multiplier for x and y coordinates, followed by a shift.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="affinetransform3D">
	<function>
		<case constructor-of="Transform3D">
			<arguments>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform from multiplier for x, y, and z coordinates, followed by a shift.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="shift">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg>
					<type><named-type name="Coords" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform.</description>
		</case>
		<case constructor-of="Transform3D">
			<arguments>
				<arg>
					<type><named-type name="Coords3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="rotate">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg identifier="angle">
					<type><named-type name="Float" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="rotate3D">
	<function>
		<case constructor-of="Transform3D">
			<arguments>
				<arg identifier="dir">
					<type><named-type name="FloatTriple" /></type>
				</arg>
				<arg identifier="angle">
					<type><named-type name="Float" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct rotation transform about given direction.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="scale">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg identifier="r">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="x">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="y">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform that scales x by <arg name="r" /><char-cdot /><arg name="x" />, and y by <arg name="r" /><char-cdot /><arg name="y" />.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="scale3D">
	<function>
		<case constructor-of="Transform3D">
			<arguments>
				<arg identifier="r">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="x">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="y">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
				<arg identifier="z">
					<type><named-type name="Float" /></type>
					<default>1</default>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Construct transform that scales x by <arg name="r" /><char-cdot /><arg name="x" />, and similarly with y and z.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="inverse">
	<function>
		<case constructor-of="Transform">
			<arguments>
				<arg>
					<type><named-type name="Transform" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Constructs the inverse of a transform.  This is only possible if the linear part of the transform is non-singular.</description>
		</case>
		<case constructor-of="Transform3D">
			<arguments>
				<arg>
					<type><named-type name="Transform3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>Constructs the inverse of a transform.  This is only possible if the linear part of the transform is non-singular.</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="spot">
	<function>
		<case constructor-of="Drawable">
			<arguments>
				<arg>
					<type><named-type name="Coords" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="width" /> <dynvar name="stroking" /></dynamic-references>
			<description>
				<p>Paints a round spot at the given coordinates.  The width and color of the spot is as if the spot was a stroke, see <binding name="stroke" />.</p>
				<p>Note that spots can also be made by stroking a closed singelton path with a round cap style.  That is,
<pre>
[spot pt]
</pre>
is equivalent to
<pre>
@cap:CAP_ROUND | [stroke emptypath--pt--cycle]
</pre>
				</p>
				<p>Also note that using <binding name="spot" /> is much more efficient than using <binding name="fill" /> on a circular path.</p>
				<p>Some <str-PDF /> viewers fail to do the obvious thing when a singleton path is painted with a stroke, and if you are targeting such viewers you could either change the implementation of <binding name="spot" /> using the command line option <a part="man" id="AllowSingletonPaths">--spot-pair=yes</a>, or use <binding name="stroke" /> on a path between two points at the same location instead of using <binding name="spot" />, like so:
<pre>
@cap:CAP_ROUND | [stroke pt--(+(0m,0m))]
</pre>
</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="stroke">
	<function>
		<case constructor-of="Drawable">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
				<arg identifier="head">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead" /></type>
				</arg>
				<arg identifier="tail">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="width" /> <dynvar name="stroking" /> <dynvar name="dash" /> <dynvar name="cap" /> <dynvar name="join" /> <dynvar name="miterlimit" /></dynamic-references>
			<description>
				<p>Paints the <arg name="path" /> argument by stroking it.  Properties such as color (<dynvar name="stroking" />), width, <abbr-etc /> are taken from the dynamic environment.</p>
				<p>The arguments <arg name="head" /> and <arg name="tail" /> define arrowheads at the corresponding ends of the stroke.  An arrowhead is defined by a function that takes the path as argument, and returns a tuple with fields <field name="picture" /> and <field name="cut" />.  Here, <field name="picture" /> shall be the grahpics that is the actual arrowhead, while <field name="cut" /> tells how much the stroke shall be shortened to not interfere with the arrowhead.  Note that the arrowhead and the stroke usually overlap, but that it is not desirable that the stroke goes all the way to the point of the arrowhead.</p>
			</description>
		</case>
		<case constructor-of="Drawable3D">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg identifier="head">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead3D" /></type>
				</arg>
				<arg identifier="tail">
					<default><binding name="NO_ARROW" /></default>
					<type><named-type name="ArrowHead3D" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="width" /> <dynvar name="stroking" /> <dynvar name="dash" /> <dynvar name="cap" /> <dynvar name="join" /> <dynvar name="miterlimit" /></dynamic-references>
			<description>
				<p>Compare with the <str-2D /> case.</p>
				<p>Note that defining arrow heads is much more intricate in <str-3D /> than in <str-2D />, and generally requires knowledge of from what angle the arrowhead will later be viewed.  If one is really eager to work around this “problem”, then what one is typically looking for is a way to delay the definition of the arrowhead until the viewing angle is known.  The key to the solution is <binding name="facing" />.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="fill">
	<function>
		<case constructor-of="Drawable">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="nonstroking" /></dynamic-references>
			<description>
				<p>Paints the <arg name="path" /> (that shall be closed) argument by filling it.  The fill color is taken from <dynvar>nonstroking</dynvar>.</p>
			</description>
		</case>
		<case constructor-of="Drawable3D">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg identifier="tiebreaker">
					<default>0</default>
					<type><named-type name="Length" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="nonstroking" /></dynamic-references>
			<description>
				<p>Paints the <arg name="path" /> (that shall be closed) argument by filling it.  The fill color is taken from <dynvar>nonstroking</dynvar>.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="list">
	<function>
		<case constructor-of="SingleList">
			<arguments>
				<sink>
				</sink>
			</arguments>
			<description>
				<p>Constructs a list of the arguments.</p>
				<p>The value created when called with no arguments is recognized by <binding name="null?" />, and should be used as a null marker for <named-type name="ConsPair" /> lists.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="cons">
	<function>
		<case constructor-of="ConsPair">
			<arguments>
				<arg identifier="car"></arg>
				<arg identifier="cdr"></arg>
			</arguments>
			<description>
				<p>Constructs a cons pair.  The arguments are not forced, which allows infinite data structures to be defined.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="range">
	<function>
		<case constructor-of="SingleList">
			<arguments>
				<arg identifier="begin">
					<type><named-type name="Integer" /></type>
				</arg>
				<arg identifier="end">
					<type><named-type name="Integer" /></type>
				</arg>
				<arg identifier="step">
					<type><named-type name="Integer" /></type>
				</arg>
				<arg identifier="count">
					<type><named-type name="Integer" /></type>
				</arg>
			</arguments>
			<description>
				<p>Constructs a range of integers.  One of the arguments must be omitted, and it is forbidden to provide <arg name="begin" />, <arg name="end" />, and <arg name="count" /> at the same time.  It is allowed to omit both <arg name="step" /> and <arg name="count" />, in which case <arg name="step" /> defaults to (a positive) 1.</p>
				<p>See the float case for the semantics of the various argument combinations.</p>
			</description>
		</case>
		<case constructor-of="SingleList">
			<arguments>
				<arg identifier="begin">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="end">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="step">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="count">
					<type><named-type name="Integer" /></type>
				</arg>
			</arguments>
			<description>
				<p>Constructs a range of real numbers.  One of the arguments must be omitted.  It is allowed to omit both <arg name="step" /> and <arg name="count" />, in which case <arg name="step" /> defaults to (a positive) 1.</p>
				<p>If <arg name="step" /> is provided, it determines the step length.  If <arg name="count" /> is provided, it must be at least 2, and determines the number of elements in the constructed range, which will begin at <arg name="begin" /> if <arg name="begin" /> is provided, and end at <arg name="end" /> if <arg name="end" /> is provided (note that achieving this using <arg name="step" /> may be inconvenient or even difficult due to problems with numeric precision).  If neither <arg name="step" /> nor <arg name="count" /> is provided, <arg name="step" /> defaults to 1.</p>
			</description>
		</case>
		<case constructor-of="SingleList">
			<arguments>
				<arg identifier="begin">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="end">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="step">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="count">
					<type><named-type name="Integer" /></type>
				</arg>
			</arguments>
			<description>
				<p>Constructs a range of integers.  One of the arguments must be omitted, and it is forbidden to omit both <arg name="step" /> and <arg name="count" />.</p>
				<p>See the float case for the semantics of the various argument combinations.</p>
			</description>
		</case>
		<body>
			<example-with-output title="Range construction" internal-id="example/ranges">
<source file="features/ranges.shape">
<![CDATA[<!--#include depth="0" virtual="$(BUILDDIR)$(EXAMPLES)features/ranges.shape" -->]]>
</source>
<stdout>
<![CDATA[<!--#include depth="0" virtual="$(BUILDDIR)$(EXAMPLES)features/ranges.stdout" -->]]>
</stdout>
			</example-with-output>
		</body>
	</function>
</system-binding>

<system-binding identifier="reverse">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Construct path where the order of pathpoints in the representation is reversed.  The constructed path looks identical to the original.</p>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="meetpaths">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Merge the two paths by merging the <field name="end" /> point of the first path with the <field name="begin" /> point of the second path.  It is not required for the two paths to intersect;  the merge operation is defined anyway by replacing the two merged points with one at the mean, taking one interpolation point form each path.  Use this to avoid vanishing spline segments when joining two consecutive paths.</p>
				<p>Hopefully, the example below expresses the idea more clearly.</p>
				<example-with-output title="Merging paths" internal-id="example/meetpaths">
					<image pdf="showcase/mergepaths_3.pdf" jpg="showcase/mergepaths_y_big.jpg" />
<source file="showcase/mergepaths.shape">
<![CDATA[<!--#include depth="0" virtual="$(BUILDDIR)$(EXAMPLES)showcase/mergepaths.shape" -->]]>
</source>
<caption>
	<p>Application of <binding name="meetpaths" />.  Note that the interesting stuff is found in <a extension="linkpaths" />.</p>
</caption>
				</example-with-output>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_balance">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Divide each spline segment in two such that the velocity is continuous at the new path point.  This will make the distance to the two interpolation points at the new path point equal, hence the name.  It turns out that this happens at spline time 0.5, so the implementation is very cheap.</p>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_inflections">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Add samples at inflection points.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_bends">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg identifier="angle">
					<type><named-type name="Float" /></type>
				</arg>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Add samples at inflection points, and so that each segment bends at most <arg name="angle" />.  Segments that need upsampling (after inflections have been removed) are sampled evenly with respect to direction.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="upsample_every">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg identifier="period">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Add sample points such that each segment is at most <arg name="period" /> long.  Segments that need upsampling are sampled evenly with respect to arc length.</p>
			</description>
		</case>
		<case constructor-of="Path3D">
			<arguments>
				<arg identifier="period">
					<type><named-type name="Length" /></type>
				</arg>
				<arg identifier="path">
					<type><named-type name="Path3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="maximizer">
	<function>
		<case constructor-of="PathSlider">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatPair" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Finds the first point on the path where the global maximum in the given direction is attained.</p>
			</description>
		</case>
		<case constructor-of="PathSlider3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="pathpoint_maximizer">
	<function>
		<case constructor-of="PathSlider">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatPair" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Finds the first path point on the path where the global maximum in the given direction is attained.</p>
			</description>
		</case>
		<case constructor-of="PathSlider3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="controlling_maximizer">
	<function>
		<case constructor-of="Coords">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatPair" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Finds the a point among the control points of the path, where the global maximum in the given direction is attained.</p>
			</description>
		</case>
		<case constructor-of="Coords3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg>
					<type><named-type name="FloatTriple" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="approximator">
	<function>
		<case constructor-of="PathSlider">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Finds the first point on the path where the global minimum in distance to the given point is attained.</p>
			</description>
		</case>
		<case constructor-of="PathSlider3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="pathpoint_approximator">
	<function>
		<case constructor-of="PathSlider">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Finds the first path point on the path where the global minimum in distance to the given point is attained.</p>
			</description>
		</case>
		<case constructor-of="PathSlider3D">
			<arguments>
				<arg>
					<type><named-type name="Path3D" /></type>
				</arg>
				<arg>
					<type><named-type name="Coords3D" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Analogous to the the <str-2D /> case.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="intersection">
	<function>
		<case constructor-of="PathSlider">
			<arguments>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
				<arg>
					<type><named-type name="Path" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="handler_NoIntersection" /></dynamic-references>
			<description>
				<p>Finds the first point on the first path where it intersects with the second path.</p>
				<p>If no intersection is found, the error handler <dynvar name="handler_NoIntersection" /> is called with the two paths as argumets.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="svg_path">
	<function>
		<case constructor-of="Path">
			<arguments>
				<arg identifier="d">
					<type><named-type name="String" /></type>
				</arg>
				<arg identifier="xunit">
					<type><named-type name="Lenth" /></type>
					<default><physical><scalar>1</scalar><unit>bp</unit></physical></default>
				</arg>
				<arg identifier="yunit">
					<type><named-type name="Lenth" /></type>
					<default><physical><scalar>1</scalar><unit>bp</unit></physical></default>
				</arg>
				<arg identifier="multi">
					<type><named-type name="Boolean" /></type>
				</arg>
				<arg identifier="singletons">
					<type><named-type name="Boolean" /></type>
					<default><const-true /></default>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Interpret the string <arg name="d" /> as an <str-SVG /> description of a path.  Generally, converting coordinates from the <str-SVG /> model to <str-Shapes /> is cumbersome, as it basically requires a drawing area in the <str-Shapes /> world to be defined and related to <str-SVG /> coordinates.  However, by disregarding the shift part of the true coordinate transform, only scaling remains to be determined, and for this there is <arg name="xunit" /> and <arg name="yunit" />.</p>
				<p>The argument <arg name="multi" /> is optional.  If provided, <const-true /> means that a <named-type name="MultiPath" /> will be returned (generally containing several sub paths of type <named-type name="Path" />), and <const-false /> means that there must be exactly one sub path, which will be returned as a <named-type name="Path" />.</p>
				<p>If <arg name="singletons" /> is false, paths with zero duration are ignored.</p>
				<p>Use this function when you'd rather use a graphical tool to define paths than writing the <str-Shapes /> code by hand.  For instance, paths can be created with <a href="http://www.gimp.org/">Gimp</a>, and exported in <str-SVG /> format.</p>
				<p>Note that <str-SVG /> graphics is typically located below the origin, while <str-Shapes /> (and <str-PDF />) programs typically locate graphics above the origin.  When determining how to shift the returned path, and this is done using <str-SVG /> information, it must be remembered that the <str-SVG /> <eq>y</eq> coordinate is increasing downwards.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="facet">
	<function>
		<case constructor-of="Drawable3D">
			<arguments>
				<arg identifier="path">
					<type><named-type name="Path" /></type>
				</arg>
				<arg identifier="n1">
					<type><template-type name="N" /></type>
				</arg>
				<arg identifier="n2">
					<type><template-type name="N" /></type>
				</arg>
				<arg identifier="n3">
					<type><template-type name="N" /></type>
				</arg>
				<arg identifier="tiebreaker">
					<type><named-type name="Length" /></type>
					<default>0</default>
				</arg>
				<arg identifier="double">
					<type><named-type name="Boolean" /></type>
				</arg>
			</arguments>
			<dynamic-references><dynvar name="nonstroking" /> <dynvar name="reflections" /> <dynvar name="autointensity" /> <dynvar name="autoscattering" /> <dynvar name="viewresolution" /> <dynvar name="shadeorder" /></dynamic-references>
			<type-templates>
				<template name="N">
					<description>
						<p>Type of surface normal.  Should either be <named-type name="SurfaceNormalGray" /> or <named-type name="SurfaceNormalRGB" />.</p>
					</description>
				</template>
			</type-templates>
			<description>
				<p>The only required argument is <arg name="path" />, which must be a flat polygon.  The three arguments of type <template-type name="N" /> will be described shortly.  The parameter <arg name="tiebreaker" /> has the same meaning as for <binding name="fill" />, and <arg name="double" /> tells whether the surface should be visible when viewed from the back.  Surfaces that are not visisble when viewed from the back allow more efficient rendering when they cover a solid body, so that one knows that the inside of the body surface should never be visible.  The default value for <arg name="double" /> depends on the presence of surface normals; if there are none, it defaults to true, otherwise it defaults to false unless the surface normals disagree on which is the visible side.</p>
				<p>Up to three surface normals may be provided (provide <arg name="n1" /> before <arg name="n2" /> and so forth).  A surface normal has a location on the surface and specifies both a normal direction to be used in light computations (although the surface is physically flat, it can be treated as if curved in the light model), and a color.  See <binding name="facetnormal" /> for more details on how to construct surface normals.  If no facet normal is provided, one is computed by using the physical normal direction of <arg name="path" />, with color determined by <dynvar name="nonstroking" />.  If just one facet normal is provided, it defines a constant normal direction and color over the whole facet.  If more than one is provided, normal direction and color are interpolated over the facet.</p>
				<p>Please refer to the documentation on the many dynamic variables accessed by this function, to learn how these affect the light computations.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="Schur_decomp">
	<function>
		<case>
			<arguments>
				<arg identifier="tf">
					<type><named-type name="Transform3D" /></type>
				</arg>
				<arg identifier="rank">
					<type><named-type name="Integer" /></type>
				</arg>
			</arguments>
			<result>
				<type>
					<structure-type>
						<field name="Q"><type><named-type name="Transform3D" /></type></field>
						<field name="U"><type><named-type name="Transform3D" /></type></field>
					</structure-type>
				</type>
			</result>
			<description>
				<p>Computes a rigid body coordinate transform that brings the transform <arg name="tf" /> into a simple form.  The linear part of the coordinate transform is given by the real Schur decomposition, ensuring that a real eigenvalue is associated with the third basis vector.  (Hence, if there is a 2 by 2 block in the Schur form, it will be in the upper left part.)  The translational part of the coordinate transform is computed to make the translational part in the new coordinates small.  The <arg name="rank"/> parameter determines how many equation to use when the translational part is computed.  If <arg name="rank" /> is not provided, it is determined automatically from singular values.  A <arg name="rank" /> of zero means that the translational part of the coordinate transform shall not be used at all.</p>
				<p>Note that the rank shall <em>not</em> be selected full (that is, <eq>3</eq>) if <arg name="tf" /> is a rigid body transformation; use <eq>2</eq> if the rotation is not close to zero, and <eq>0</eq> otherwise (or use the automatic selection).  Compare Chasles' theorem, which says that the new transform will in general have a non-trivial translational part.</p>
<example-with-output title="Schur decomposition" internal-id="example/schur_decomp">
<source file="doc/schur.shape">
<![CDATA[<!--#include depth="0" virtual="$(BUILDDIR)$(EXAMPLES)doc/schur.shape" -->]]>
</source>
<stdout>
<![CDATA[<!--#include depth="0" virtual="$(BUILDDIR)$(EXAMPLES)doc/schur.stdout" -->]]>
</stdout>
<caption>
	<p>The generalization of real Schur decomposition to also include a translation.  It can be seen that rank <eq>2</eq> is selected for a rigid body transform with non-trivial rotation.</p>
</caption>
				</example-with-output>
			</description>
		</case>
	</function>
</system-binding>


</section>
