##needs conssupport

/**
N := 1000:
R := [evalf(seq(2/N*(N-i),i=1..N))]:
phi := [evalf(seq(1.4*Pi/N*(N-i)+0.5,i=1..N))]:
p3 := plot3d(sin(x*y),x=-2.1..2.1,y=-2.1..2.1,grid=[15,15],style=patch,color=white): # 2.1  [15,15] el. [25,25] för hög eller

points:= [seq([R[i]*sin(phi[i]),R[i]*cos(phi[i]),sin(R[i]*sin(phi[i])*R[i]*cos(phi[i]))],i=1..N)]:
p4 := pointplot3d(points,style=LINE,thickness=2,color=black):
p5 := pointplot3d(points[-1],color=black,symbol=solidsphere,symbolsize=20):
p6 := pointplot3d(points[1],color=black,symbol=solidsphere,symbolsize=20):

display(p3,p4,p5,orientation=[-17,25]);
**/

R: 5cm
u: R/2.1

/** The function describing the manifold.
 **/
surfz: \ p .> (0.2*R) * [sin (p.x/u) * (p.y/u)]

/** A general-purpose helper.
 **/
surfit: \ f p .> ( p.x, p.y, [f p] )

/** A general-purpose surface-circle.
 **/
surfaceCircle: \ f r c sides:'12 .>
{
  mid: [surfit f c]
	[[range '0 sides-'1].foldl
   \ p e .> p & [fill mid--[surfit f c+r*[dir (360°*e)/sides]]--[surfit f c+r*[dir (360°*(e+'1))/sides]]--cycle]
	 null3D]
}

/** A path on our surface.
 **/
points:
{
  N: '100
	[[range '1 N].foldl
	 \ p i .>
	 	 p--[surfit surfz (2/N)*(N-i)*u*[dir 90°-(1.4*(180°/N)*(N-i)+0.5)]]
   emptypath3D]
}


foldpairsl:
{
  helper: \ op nullRes last lst .> [if [null? lst] nullRes [helper op [op nullRes last lst.car] lst.car lst.cdr]]

  \ op nullRes lst .>
    [if [null? lst]
			lst
		 	[helper op nullRes lst.car lst.cdr]]
}

functionMesh: \ zMap xRange yRange step:'1 .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
  [foldl
    \ p x .>
			p
			&
			[stroke
        [yRange.foldl
           \ p y .> p--[xyz (x,y)]
           emptypath3D
			]]
    null3D
		[sublist [consify xRange] step]
  ]
	&
  [foldl
    \ p y .>
			p
			&
			[stroke
        [xRange.foldl
           \ p x .> p--[xyz (x,y)]
           emptypath3D
			]]
    null3D
		[sublist [consify yRange] step]
  ]
}

functionSurface: \ zMap xRange yRange .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
	xConsRange: [consify xRange]
	yConsRange: [consify yRange]
  [foldpairsl
    \ p x1 x2 .>
			p
			&
      [foldpairsl
         \ p y1 y2 .>
          p
					&
					{
					  p11: [xyz (x1,y1)]
					  p12: [xyz (x1,y2)]
					  p21: [xyz (x2,y1)]
					  p22: [xyz (x2,y2)]
					  pc: [xyz (0.5*(x1+x2),0.5*(y1+y2))]
						[fill pc--p11--p12--cycle]
						&
						[fill pc--p12--p22--cycle]
						&
						[fill pc--p22--p21--cycle]
						&
						[fill pc--p21--p11--cycle]
/**
						&
						[stroke p11--pc--p22]
						&
						[stroke p12--pc--p21]
**/
					}
         null3D
				yConsRange
			]
    null3D
		xConsRange
  ]
/**
	&
	[functionMesh zMap xRange yRange]
**/
}

ridgeLines: \ zMap xRange yRange tf .>
{
  xyz: \ p .> ( p.x, p.y, [zMap p] )
	test: \ a b c d e .>
	  {
		  da: [normalized a - b]
		  dc: [normalized c - b]
			dm0: 0.5 * ( da + dc )
			dm: [if dm0 * ( d - b ) > 0m dm0 ~dm0]
		  de: [normalized e - b]
			de*dm < da*dm
    }
	xConsRange: [consify xRange]
	yConsRange: [consify yRange]
  [foldpairsl
    \ p x1 x2 .>
      [foldpairsl
        \ p y1 y2 .>
					{
					  p11: view [] tf [] [xyz (x1,y1)]
					  p12: view [] tf [] [xyz (x1,y2)]
					  p21: view [] tf [] [xyz (x2,y1)]
					  p22: view [] tf [] [xyz (x2,y2)]
					  pc:  view [] tf [] [xyz (0.5*(x1+x2),0.5*(y1+y2))]
						pc3D: [xyz (0.5*(x1+x2),0.5*(y1+y2))]
						p
						&
						[if [test p21 p11 p12 p22 pc] [stroke [xyz (x1,y1)]--pc3D] null3D]
						&
						[if [test p11 p12 p22 p21 pc] [stroke [xyz (x1,y2)]--pc3D] null3D]
						&
						[if [test p12 p22 p21 p11 pc] [stroke [xyz (x2,y2)]--pc3D] null3D]
						&
						[if [test p22 p21 p11 p12 pc] [stroke [xyz (x2,y1)]--pc3D] null3D]
					}
        p
				yConsRange
			]
    null3D
		xConsRange
  ]
}

T_view: [rotate3D dir:(1,0,0) angle:~90°-~17°]*[rotate3D dir:(0,0,1) angle:~90°-25°]

N_major: '15
N_minor: '3
xRange: [range ~R R count: N_major * N_minor + '1]
yRange: [range ~R R count: N_major * N_minor + '1]

•page << [view
				   T_view
					 []
					 ( newZSorter
					   <<   @nonstroking:OCCLUDING
						    & @width: 0.3bp
					 	 		| [functionSurface surfz xRange yRange]
					   << @width: 0.3bp
					 	 		| [functionMesh surfz xRange yRange N_minor]
					   << @width: 0.3bp
					 	 		| [ridgeLines surfz xRange yRange T_view]
					 )
				 ]
•page << [view
				   T_view
					 []
					 ( newGroup3D
					 	 << @width:1.5bp & @cap:CAP_ROUND | [stroke points]
						 << [surfaceCircle surfz 4bp (points.begin.p.x,points.begin.p.y)]
						 << [surfaceCircle surfz 4bp (points.end.p.x,points.end.p.y)]
					 )
				 ]
