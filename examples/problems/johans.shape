##needs conssupport

/**
N := 1000:
R := [evalf(seq(2/N*(N-i),i=1..N))]:
phi := [evalf(seq(1.4*Pi/N*(N-i)+0.5,i=1..N))]:
p3 := plot3d(sin(x*y),x=-2.1..2.1,y=-2.1..2.1,grid=[15,15],style=patch,color=white): # 2.1  [15,15] el. [25,25] för hög eller

points:= [seq([R[i]*sin(phi[i]),R[i]*cos(phi[i]),sin(R[i]*sin(phi[i])*R[i]*cos(phi[i]))],i=1..N)]:
p4 := pointplot3d(points,style=LINE,thickness=2,color=black):
p5 := pointplot3d(points[-1],color=black,symbol=solidsphere,symbolsize=20):
p6 := pointplot3d(points[1],color=black,symbol=solidsphere,symbolsize=20):

display(p3,p4,p5,orientation=[-17,25]);
**/

R: 5cm

surfz: \ p .> 1cm * [sin (p.x/R)*2.1 * (p.y/R)*2.1]


foldpairsl:
{
  helper: \ op nullRes last lst .> [if [null? lst] nullRes [helper op [op nullRes last lst.car] lst.car lst.cdr]]

  \ op nullRes lst .>
    [if [null? lst]
	    lst
		 	[helper op nullRes lst.car lst.cdr]]
}

functionSurface: \ zMap xRange yRange .>
  [foldpairsl
    \ p x1 x2 .>
			p
			&
      [foldpairsl
         \ p y1 y2 .>
          p
					&
					{
					  z11: [zMap (x1,y1)]
					  z12: [zMap (x1,y2)]
					  z21: [zMap (x2,y1)]
					  z22: [zMap (x2,y2)]
						[fill (x1,y1,z11)--(x1,y2,z12)--(x2,y2,z22)--cycle]
						&
						[fill (x1,y1,z11)--(x2,y2,z22)--(x2,y1,z21)--cycle]
						&
						[stroke (x1,y1,z11)--(x1,y2,z12)--(x2,y2,z22)--(x2,y1,z21)--cycle]
					}
         null3D
				yRange
			]
    null3D
		xRange
  ]

T_View: [rotate3D dir:(1,0,0) angle:~(90°-17°)]*[rotate3D dir:(0,0,1) angle:~25°]

•page << [view
				   T_View
					 []
					 ( newZSorter <<   @nonstroking:[gray 0.7]
					 	 							 & @width: 0.3bp
					 	 							 | [functionSurface surfz
					 	 							 										consify[][range ~5cm step:20mm count:'2]
																							consify[][range ~3cm 3cm 20mm]
|**					 	 							 										consify[][range ~R R count:'10]
|**																							consify[][range ~R R count:'10]
																								]
					 )
				 ]
