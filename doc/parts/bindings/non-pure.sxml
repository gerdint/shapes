<!-- This file is part of Shapes.                                           -->
<!--                                                                        -->
<!-- Shapes is free software: you can redistribute it and/or modify         -->
<!-- it under the terms of the GNU General Public License as published by   -->
<!-- the Free Software Foundation, either version 3 of the License, or      -->
<!-- any later version.                                                     -->
<!--                                                                        -->
<!-- Shapes is distributed in the hope that it will be useful,              -->
<!-- but WITHOUT ANY WARRANTY; without even the implied warranty of         -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          -->
<!-- GNU General Public License for more details.                           -->
<!--                                                                        -->
<!-- You should have received a copy of the GNU General Public License      -->
<!-- along with Shapes.  If not, see <http://www.gnu.org/licenses/>.        -->
<!--                                                                        -->
<!-- Copyright 2008 Henrik Tidefelt                                         -->

<section id="bindings/non-pure-functions">
<title>Non-pure functions</title>
<top>
<p>This section contains non-pure functions that are used to modify states.</p>
</top>

<system-binding identifier="erase">
	<function>
		<case>
			<arguments>
				<state identifier="group">
					<type><named-state-type name="Group" /></type>
				</state>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Erase the contents.</p>
				<p>A common application of this is when <state name="page" /> has been used to define the contents of the pages in <state name="catalog" />.  Then, when <state name="catalog" /> is non-empty at the end of the program, it is an error if <state name="page" /> is also non-tmpty.  All you have to do then is to write
<pre>
[erase •page]
</pre>
at the end of the program.</p>
			</description>
		</case>
		<case>
			<arguments>
				<state identifier="group">
					<type><named-state-type name="Group3D" /></type>
				</state>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Erase the contents.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="remove">
	<function>
		<case>
			<arguments>
				<state identifier="group">
					<type><named-state-type name="Group" /></type>
				</state>
				<arg identifier="key">
					<type><named-type name="Symbol" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Remove <em>shallow</em> tagged objects with the key <arg name="key" />.</p>
				<p>Here, <em>shallow</em> refers to objects that were tacked on directly to the state.  For instance,
<pre>
•page &lt;&lt; [shift (1cm,0cm)] [] [tag 'a [stroke (0cm,0cm)--(1cm,1cm)]]
[remove •page 'a]
</pre>
will <em>not</em> remove the stroke from the page, since the value being tacked on to the state is transformed.  To make it work, apply the transform to the object being tagged:
<pre>
•page &lt;&lt; [tag 'a  [[shift (1cm,0cm)] [stroke (0cm,0cm)--(1cm,1cm)]]]
</pre>
</p>
			</description>
			<see-also>
				<binding name="tag" />
			</see-also>
		</case>
		<case>
			<arguments>
				<state identifier="group">
					<type><named-state-type name="Group3D" /></type>
				</state>
				<arg identifier="key">
					<type><named-type name="Symbol" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Remove <em>shallow</em> tagged objects with the key <arg name="key" />.</p>
			</description>
		</case>
	</function>
</system-binding>

<system-binding identifier="setbboxgroup">
	<function>
		<case>
			<arguments>
				<state identifier="catalog">
					<type><named-state-type name="Catalog" /></type>
				</state>
				<arg identifier="key">
					<type><named-type name="Symbol" /></type>
				</arg>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Define the bounding box key to be used for pages subsequently tacked on to the catalog.  These pages will get equal media boxes in the end, being the smallest that contains all the bounding boxes of the pages in the group.</p>
			</description>
		</case>
		<case>
			<arguments>
				<state identifier="catalog">
					<type><named-state-type name="Catalog" /></type>
				</state>
			</arguments>
			<dynamic-references></dynamic-references>
			<description>
				<p>Clear the bounding box key to be used for pages subsequently tacked on to the catalog.  Pages will get a media box equal to their own bounding box.</p>
			</description>
		</case>
	</function>
</system-binding>

</section>
